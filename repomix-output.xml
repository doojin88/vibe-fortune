This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: ./src/**/*, ./*.ts, ./*.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  app/
    (protected)/
      dashboard/
        new/
          page.tsx
        page.tsx
      subscription/
        fail/
          page.tsx
        success/
          page.tsx
        page.tsx
      layout.tsx
    api/
      [[...hono]]/
        route.ts
      subscription/
        charge/
          route.ts
        confirm/
          route.ts
        process/
          route.ts
      webhooks/
        clerk/
          route.ts
    dashboard/
      results/
        [id]/
          page.tsx
    example/
      page.tsx
    login/
      page.tsx
    signup/
      page.tsx
    favicon.ico
    globals.css
    layout.tsx
    page.tsx
    providers.tsx
  backend/
    config/
      index.ts
    hono/
      app.ts
      context.ts
    http/
      response.ts
    middleware/
      context.ts
      error.ts
      supabase.ts
    supabase/
      client.ts
  components/
    home/
      faq-section.tsx
      feature-card.tsx
      features-section.tsx
      footer.tsx
      hero-section.tsx
      pricing-card.tsx
      pricing-section.tsx
    layout/
      dashboard-header.tsx
      dashboard-sidebar.tsx
      home-header.tsx
      mobile-sidebar.tsx
    ui/
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      checkbox.tsx
      date-picker.tsx
      dialog.tsx
      dropdown-menu.tsx
      empty-state.tsx
      file-upload.tsx
      form.tsx
      input.tsx
      label.tsx
      popover.tsx
      radio-group.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      spinner.tsx
      textarea.tsx
      time-picker.tsx
      toast.tsx
      toaster.tsx
    markdown-renderer.tsx
  constants/
    auth.ts
    env.ts
    server-env.ts
  features/
    auth/
      context/
        current-user-context.tsx
      hooks/
        useCurrentUser.ts
      server/
        load-current-user.ts
      types.ts
    example/
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
      components/
        example-status.tsx
      hooks/
        useExampleQuery.ts
      lib/
        dto.ts
    saju/
      actions/
        create-saju-test.ts
        delete-saju-test.ts
        load-more-tests.ts
      components/
        analysis-info-card.tsx
        analysis-result-section.tsx
        dashboard-content.tsx
        delete-test-dialog.tsx
        load-more-button.tsx
        navigation-buttons.tsx
        new-analysis-form.tsx
        result-detail-client.tsx
        saju-test-card.tsx
        search-bar.tsx
      queries/
        get-saju-test.ts
        get-saju-tests.ts
      types/
        input.ts
        result.ts
    subscription/
      actions/
        cancel-subscription.ts
        resume-subscription.ts
      components/
        cancel-subscription-dialog.tsx
        resume-subscription-dialog.tsx
        subscribe-pro-dialog.tsx
        subscription-card.tsx
        subscription-status.tsx
      queries/
        get-subscription.ts
  hooks/
    use-toast.ts
  lib/
    gemini/
      client.ts
      prompts.ts
    remote/
      api-client.ts
    supabase/
      admin-client.ts
      browser-client.ts
      client.ts
      server-client.ts
      server.ts
      types.ts
    toss-payments/
      api.ts
      index.ts
    utils/
      clipboard.ts
      date.ts
    utils.ts
  utils/
    validation.ts
  middleware.ts
.mcp.json
components.json
next.config.ts
package.json
playwright.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/(protected)/subscription/fail/page.tsx">
/**
 * 구독 실패 페이지
 *
 * 토스페이먼츠 카드 등록 실패 또는 사용자 취소 시 리다이렉트되는 페이지입니다.
 */

'use client';

import { useSearchParams, useRouter } from 'next/navigation';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { XCircle, AlertCircle } from 'lucide-react';

export default function SubscriptionFailPage() {
  const searchParams = useSearchParams();
  const router = useRouter();

  const code = searchParams.get('code');
  const message = searchParams.get('message');

  const getErrorMessage = () => {
    if (code === 'USER_CANCEL') {
      return '사용자가 카드 등록을 취소했습니다.';
    }
    return message || '카드 등록 중 오류가 발생했습니다.';
  };

  return (
    <div className="min-h-screen flex items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-center flex items-center justify-center gap-2">
            <XCircle className="h-6 w-6 text-destructive" />
            구독 실패
          </CardTitle>
          <CardDescription className="text-center">
            Pro 구독 신청이 완료되지 않았습니다.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="flex gap-3 rounded-md border border-destructive/50 bg-destructive/10 p-4 text-sm text-destructive">
            <AlertCircle className="h-5 w-5 flex-shrink-0" />
            <div>
              <p className="font-medium">오류 내용</p>
              <p className="mt-1 text-xs">
                {getErrorMessage()}
              </p>
            </div>
          </div>

          <div className="space-y-2 text-sm text-muted-foreground">
            <h4 className="font-medium text-foreground">다음과 같은 경우에 실패할 수 있습니다:</h4>
            <ul className="space-y-1 list-disc list-inside">
              <li>카드 정보를 잘못 입력한 경우</li>
              <li>본인인증에 실패한 경우</li>
              <li>카드사에서 거절한 경우</li>
              <li>사용자가 결제창을 닫은 경우</li>
            </ul>
          </div>

          <div className="flex gap-2 w-full">
            <Button
              variant="outline"
              onClick={() => router.push('/dashboard')}
              className="flex-1"
            >
              대시보드
            </Button>
            <Button
              onClick={() => router.push('/subscription')}
              className="flex-1"
            >
              다시 시도
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(protected)/subscription/success/page.tsx">
/**
 * 구독 성공 페이지
 *
 * 토스페이먼츠 카드 등록 성공 후 리다이렉트되는 페이지입니다.
 * authKey를 받아 서버에 빌링키 발급 및 첫 결제를 요청합니다.
 */

'use client';

import { useEffect, useState } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { CheckCircle2, Loader2, XCircle } from 'lucide-react';

export default function SubscriptionSuccessPage() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const confirmSubscription = async () => {
      const authKey = searchParams.get('authKey');
      const customerKey = searchParams.get('customerKey') || sessionStorage.getItem('customerKey');

      if (!authKey || !customerKey) {
        setError('필수 파라미터가 누락되었습니다.');
        setLoading(false);
        return;
      }

      try {
        const response = await fetch('/api/subscription/confirm', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            authKey,
            customerKey,
          }),
        });

        const data = await response.json();

        if (response.ok && data.success) {
          setSuccess(true);
          // customerKey 세션 삭제
          sessionStorage.removeItem('customerKey');

          // 3초 후 구독 관리 페이지로 이동
          setTimeout(() => {
            router.push('/subscription');
          }, 3000);
        } else {
          setError(data.error || '구독 처리에 실패했습니다.');
        }
      } catch (err: any) {
        console.error('구독 확인 실패:', err);
        setError('구독 처리에 실패했습니다. 다시 시도해주세요.');
      } finally {
        setLoading(false);
      }
    };

    confirmSubscription();
  }, [searchParams, router]);

  return (
    <div className="min-h-screen flex items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-center">
            {loading && '구독 처리 중...'}
            {!loading && success && '구독 완료!'}
            {!loading && error && '구독 실패'}
          </CardTitle>
          <CardDescription className="text-center">
            {loading && '잠시만 기다려주세요.'}
            {!loading && success && '성공적으로 Pro 구독이 등록되었습니다.'}
            {!loading && error && '구독 처리 중 오류가 발생했습니다.'}
          </CardDescription>
        </CardHeader>
        <CardContent className="flex flex-col items-center gap-6">
          {loading && (
            <Loader2 className="h-16 w-16 animate-spin text-primary" />
          )}
          {!loading && success && (
            <>
              <CheckCircle2 className="h-16 w-16 text-green-500" />
              <p className="text-center text-sm text-muted-foreground">
                3초 후 구독 관리 페이지로 이동합니다.
              </p>
              <Button onClick={() => router.push('/subscription')} className="w-full">
                바로 이동하기
              </Button>
            </>
          )}
          {!loading && error && (
            <>
              <XCircle className="h-16 w-16 text-destructive" />
              <p className="text-center text-sm text-muted-foreground">
                {error}
              </p>
              <div className="flex gap-2 w-full">
                <Button variant="outline" onClick={() => router.push('/subscription')} className="flex-1">
                  구독 관리
                </Button>
                <Button onClick={() => router.push('/dashboard')} className="flex-1">
                  대시보드
                </Button>
              </div>
            </>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(protected)/subscription/page.tsx">
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getSubscription } from '@/features/subscription/queries/get-subscription';
import { SubscriptionCard } from '@/features/subscription/components/subscription-card';
import { SubscribeProDialog } from '@/features/subscription/components/subscribe-pro-dialog';
import { CancelSubscriptionDialog } from '@/features/subscription/components/cancel-subscription-dialog';
import { ResumeSubscriptionDialog } from '@/features/subscription/components/resume-subscription-dialog';
import { currentUser } from '@clerk/nextjs/server';

export default async function SubscriptionPage() {
  const { userId } = await auth();
  if (!userId) {
    redirect('/');
  }

  const user = await currentUser();
  const subscription = await getSubscription();

  if (!subscription) {
    return (
      <div className="container max-w-4xl py-8">
        <div className="text-center">
          <h1 className="text-3xl font-bold mb-4">Subscription</h1>
          <p className="text-muted-foreground">
            Failed to load subscription information.
          </p>
        </div>
      </div>
    );
  }

  const { status, nextBillingDate } = subscription;
  const customerEmail = user?.primaryEmailAddress?.emailAddress || '';
  const customerName = user?.fullName || user?.firstName || '';

  return (
    <div className="container max-w-4xl py-8 space-y-8">
      <div>
        <h1 className="text-3xl font-bold mb-2">Subscription Management</h1>
        <p className="text-muted-foreground">
          View and manage your subscription status.
        </p>
      </div>

      <SubscriptionCard email={customerEmail} subscription={subscription} />

      <div className="flex justify-center">
        {status === 'free' && (
          <SubscribeProDialog
            customerEmail={customerEmail}
            customerName={customerName}
          />
        )}

        {status === 'pro' && (
          <CancelSubscriptionDialog nextBillingDate={nextBillingDate} />
        )}

        {status === 'cancelled' && (
          <ResumeSubscriptionDialog nextBillingDate={nextBillingDate} />
        )}

        {status === 'payment_failed' && (
          <div className="space-y-4 w-full max-w-md">
            <p className="text-center text-sm text-muted-foreground">
              Payment failed. Please register your card information again.
            </p>
            <SubscribeProDialog
              customerEmail={customerEmail}
              customerName={customerName}
            />
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/api/[[...hono]]/route.ts">
import { handle } from 'hono/vercel';
import { createHonoApp } from '@/backend/hono/app';

const app = createHonoApp();

export const GET = handle(app);
export const POST = handle(app);
export const PUT = handle(app);
export const PATCH = handle(app);
export const DELETE = handle(app);
export const OPTIONS = handle(app);

export const runtime = 'nodejs';
</file>

<file path="src/app/api/subscription/charge/route.ts">
/**
 * 자동결제 승인 API
 *
 * 빌링키로 정기 결제를 실행합니다.
 * 빌링키 발급 후 첫 결제 및 Cron Job에서 정기 결제 시 호출됩니다.
 *
 * @route POST /api/subscription/charge
 */

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin-client';
import { chargeBilling, TossPaymentsError } from '@/lib/toss-payments/api';
import { v4 as uuidv4 } from 'uuid';

/**
 * 자동결제 승인 요청 스키마
 */
interface ChargeRequest {
  billingKey: string;
  customerKey: string;
  amount: number;
  userId: string;
  subscriptionId?: string;
}

export async function POST(request: NextRequest) {
  try {
    // 1. 요청 데이터 검증
    const body: ChargeRequest = await request.json();
    const { billingKey, customerKey, amount, userId, subscriptionId } = body;

    if (!billingKey || !customerKey || !amount || !userId) {
      return NextResponse.json(
        { error: '필수 파라미터가 누락되었습니다.' },
        { status: 400 }
      );
    }

    // 2. 주문 ID 생성
    const orderId = `ORDER_${Date.now()}_${uuidv4().slice(0, 8)}`;

    console.log('자동결제 승인 시작:', { userId, orderId, amount });

    // 3. 토스페이먼츠 API 호출
    const payment = await chargeBilling({
      billingKey,
      customerKey,
      amount,
      orderId,
      orderName: 'Vibe Fortune Pro 구독',
    });

    console.log('자동결제 승인 성공:', { paymentKey: payment.paymentKey });

    // 4. 결제 내역 저장
    const supabase = createAdminClient();

    // subscription_id 조회 (제공되지 않은 경우)
    let subId: string | undefined = subscriptionId;
    if (!subId) {
      const { data: subscription } = await supabase
        .from('subscriptions')
        .select('id')
        .eq('billing_key', billingKey)
        .maybeSingle();

      subId = (subscription as any)?.id;
    }

    if (subId) {
      const { error: paymentError } = await supabase.from('payments').insert({
        user_id: userId,
        subscription_id: subId,
        payment_key: payment.paymentKey,
        order_id: orderId,
        amount,
        status: 'done',
        paid_at: new Date().toISOString(),
      } as any);

      if (paymentError) {
        console.error('결제 내역 저장 실패:', paymentError);
      } else {
        console.log('결제 내역 저장 완료:', { orderId });
      }
    }

    return NextResponse.json({
      success: true,
      paymentKey: payment.paymentKey,
      orderId: payment.orderId,
    });
  } catch (error: any) {
    console.error('자동결제 승인 실패:', error);

    // 토스페이먼츠 API 에러 처리
    if (error instanceof TossPaymentsError) {
      // 한도초과 또는 잔액부족 에러
      if (error.code === 'REJECT_CARD_PAYMENT') {
        return NextResponse.json(
          { error: '한도초과 또는 잔액부족입니다.', code: error.code },
          { status: 400 }
        );
      }

      return NextResponse.json(
        { error: error.message, code: error.code },
        { status: error.statusCode }
      );
    }

    // 일반 에러 처리
    return NextResponse.json(
      { error: error.message || '결제에 실패했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/subscription/confirm/route.ts">
/**
 * 빌링키 발급 및 첫 결제 API
 *
 * 카드 등록 후 authKey를 받아 빌링키를 발급하고,
 * 첫 결제를 진행한 후 구독 정보를 저장합니다.
 *
 * @route POST /api/subscription/confirm
 */

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { createAdminClient } from '@/lib/supabase/admin-client';
import { issueBillingKey, TossPaymentsError } from '@/lib/toss-payments/api';
import { env } from '@/constants/env';
import type { Database } from '@/lib/supabase/types';

/**
 * 빌링키 발급 요청 스키마
 */
interface ConfirmRequest {
  authKey: string;
  customerKey: string;
}

export async function POST(request: NextRequest) {
  try {
    // 1. 사용자 인증 확인
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json(
        { error: '인증이 필요합니다.' },
        { status: 401 }
      );
    }

    // 2. 요청 데이터 검증
    const body: ConfirmRequest = await request.json();
    const { authKey, customerKey } = body;

    if (!authKey || !customerKey) {
      return NextResponse.json(
        { error: '필수 파라미터가 누락되었습니다.' },
        { status: 400 }
      );
    }

    // 3. 빌링키 발급
    console.log('빌링키 발급 시작:', { userId, customerKey });
    const billingData = await issueBillingKey({ authKey, customerKey });

    // 4. Supabase에 구독 정보 저장
    const supabase = createAdminClient();

    // 기존 구독이 있는지 확인
    const { data: existingSubscription } = await supabase
      .from('subscriptions')
      .select('id')
      .eq('user_id', userId)
      .single();

    if (existingSubscription) {
      return NextResponse.json(
        { error: '이미 활성화된 구독이 있습니다.' },
        { status: 400 }
      );
    }

    // 다음 결제일: 현재로부터 30일 후
    const nextBillingDate = new Date();
    nextBillingDate.setDate(nextBillingDate.getDate() + 30);

    const { data: subscription, error: dbError } = await supabase
      .from('subscriptions')
      .insert({
        user_id: userId,
        billing_key: billingData.billingKey,
        customer_key: customerKey,
        card_number: billingData.card?.number?.slice(-4) || null,
        card_type: billingData.card?.cardType || null,
        card_company: billingData.card?.issuerName || null,
        status: 'active',
        next_billing_date: nextBillingDate.toISOString(),
      } as any)
      .select()
      .single();

    if (dbError || !subscription) {
      console.error('구독 정보 저장 실패:', dbError);
      throw new Error('구독 정보 저장에 실패했습니다.');
    }

    // 5. 첫 결제 진행
    const sub = subscription as any;
    console.log('첫 결제 시작:', { subscriptionId: sub.id });

    const chargeResponse = await fetch(
      `${env.NEXT_PUBLIC_BASE_URL}/api/subscription/charge`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          billingKey: billingData.billingKey,
          customerKey,
          amount: 9900,
          userId,
          subscriptionId: sub.id,
        }),
      }
    );

    if (!chargeResponse.ok) {
      // 첫 결제 실패 시 구독 삭제
      console.error('첫 결제 실패');
      await supabase
        .from('subscriptions')
        .delete()
        .eq('id', sub.id);

      throw new Error('첫 결제에 실패했습니다.');
    }

    // 6. users 테이블 업데이트
    const adminSupabase = createAdminClient();
    const { error: userError } = await (adminSupabase as any)
      .from('users')
      .update({
        subscription_status: 'pro',
        test_count: 10,
      })
      .eq('id', userId);

    if (userError) {
      console.error('사용자 정보 업데이트 실패:', userError);
    }

    console.log('구독 등록 완료:', { userId, subscriptionId: sub.id });

    return NextResponse.json({
      success: true,
      message: '구독이 성공적으로 등록되었습니다.',
    });
  } catch (error: any) {
    console.error('빌링키 발급 실패:', error);

    // 토스페이먼츠 API 에러 처리
    if (error instanceof TossPaymentsError) {
      return NextResponse.json(
        { error: error.message, code: error.code },
        { status: error.statusCode }
      );
    }

    // 일반 에러 처리
    return NextResponse.json(
      { error: error.message || '빌링키 발급에 실패했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/subscription/process/route.ts">
/**
 * Cron Job 정기 결제 처리 API
 *
 * 매일 오전 2시 Supabase Cron에서 호출되어 정기 결제를 처리합니다.
 * - 오늘이 결제일인 활성 구독을 조회하여 결제 실행
 * - 결제 성공 시: 다음 결제일 업데이트 및 검사 횟수 충전
 * - 결제 실패 시: 구독 상태를 payment_failed로 변경
 * - 취소 예약 구독: 빌링키 삭제 및 해지 처리
 *
 * @route POST /api/subscription/process
 */

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin-client';
import { deleteBillingKey } from '@/lib/toss-payments/api';
import { serverEnv } from '@/constants/server-env';
import { env } from '@/constants/env';

export async function POST(request: NextRequest) {
  try {
    // 1. Cron Secret 인증
    const cronSecret = request.headers.get('x-cron-secret');

    if (cronSecret !== serverEnv.CRON_SECRET) {
      console.error('Cron Secret 불일치');
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('Cron Job 시작:', new Date().toISOString());

    const supabase = createAdminClient();
    const today = new Date().toISOString().split('T')[0];

    // 2. 오늘이 결제일인 활성 구독 조회
    const { data: subscriptions, error } = await (supabase as any)
      .from('subscriptions')
      .select('*')
      .eq('status', 'active')
      .lte('next_billing_date', today);

    if (error) {
      console.error('구독 조회 실패:', error);
      throw error;
    }

    console.log(`처리할 구독 수: ${subscriptions?.length || 0}`);

    const results = [];

    // 3. 각 구독에 대해 결제 처리
    for (const subscription of subscriptions || []) {
      try {
        console.log(`구독 처리 시작: ${subscription.id}`);

        // 자동결제 API 호출
        const chargeResponse = await fetch(
          `${env.NEXT_PUBLIC_BASE_URL}/api/subscription/charge`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              billingKey: subscription.billing_key,
              customerKey: subscription.customer_key,
              amount: 9900,
              userId: subscription.user_id,
              subscriptionId: subscription.id,
            }),
          }
        );

        if (chargeResponse.ok) {
          // 결제 성공
          console.log(`결제 성공: ${subscription.id}`);

          // 다음 결제일 업데이트 (30일 후)
          const nextBillingDate = new Date();
          nextBillingDate.setDate(nextBillingDate.getDate() + 30);

          await (supabase as any)
            .from('subscriptions')
            .update({
              last_billing_date: new Date().toISOString(),
              next_billing_date: nextBillingDate.toISOString(),
            })
            .eq('id', subscription.id);

          // 검사 횟수 충전
          await (supabase as any)
            .from('users')
            .update({ test_count: 10 })
            .eq('id', subscription.user_id);

          results.push({
            subscriptionId: subscription.id,
            success: true,
          });
        } else {
          // 결제 실패
          const errorData = await chargeResponse.json();
          console.error(`결제 실패: ${subscription.id}`, errorData);

          // 구독 상태를 payment_failed로 변경
          await (supabase as any)
            .from('subscriptions')
            .update({ status: 'payment_failed' })
            .eq('id', subscription.id);

          await (supabase as any)
            .from('users')
            .update({ subscription_status: 'payment_failed' })
            .eq('id', subscription.user_id);

          results.push({
            subscriptionId: subscription.id,
            success: false,
            error: errorData.error || 'Payment failed',
          });
        }
      } catch (error: any) {
        console.error(`구독 ${subscription.id} 처리 실패:`, error);
        results.push({
          subscriptionId: subscription.id,
          success: false,
          error: error.message,
        });
      }
    }

    // 4. 취소 예약 구독 해지 처리
    const { data: cancelledSubscriptions } = await (supabase as any)
      .from('subscriptions')
      .select('*')
      .eq('status', 'cancelled')
      .lt('next_billing_date', today);

    console.log(`해지할 구독 수: ${cancelledSubscriptions?.length || 0}`);

    for (const subscription of cancelledSubscriptions || []) {
      try {
        console.log(`구독 해지 시작: ${subscription.id}`);

        // 빌링키 삭제 (토스페이먼츠 API)
        await deleteBillingKey({
          billingKey: subscription.billing_key,
          customerKey: subscription.customer_key,
        });

        // 구독 상태를 terminated로 변경
        await (supabase as any)
          .from('subscriptions')
          .update({
            status: 'terminated',
            billing_key_deleted_at: new Date().toISOString(),
          })
          .eq('id', subscription.id);

        // 사용자 상태를 free로 변경 및 검사 횟수 0으로 초기화
        await (supabase as any)
          .from('users')
          .update({
            subscription_status: 'free',
            test_count: 0,
          })
          .eq('id', subscription.user_id);

        console.log(`구독 해지 완료: ${subscription.id}`);
      } catch (error: any) {
        console.error(`구독 ${subscription.id} 해지 실패:`, error);
      }
    }

    console.log('Cron Job 완료:', {
      processed: results.length,
      terminated: cancelledSubscriptions?.length || 0,
    });

    return NextResponse.json({
      success: true,
      processed: results.length,
      results,
      terminated: cancelledSubscriptions?.length || 0,
    });
  } catch (error: any) {
    console.error('정기 결제 처리 실패:', error);
    return NextResponse.json(
      { error: error.message || '정기 결제 처리에 실패했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/webhooks/clerk/route.ts">
import { headers } from 'next/headers';
import { Webhook } from 'svix';
import { WebhookEvent } from '@clerk/nextjs/server';
import { createAdminClient } from '@/lib/supabase/admin-client';
import { serverEnv } from '@/constants/server-env';

export async function POST(req: Request) {
  const WEBHOOK_SECRET = serverEnv.CLERK_WEBHOOK_SECRET;

  if (!WEBHOOK_SECRET) {
    return new Response('Webhook secret not configured', { status: 500 });
  }

  // 헤더 가져오기
  const headerPayload = await headers();
  const svix_id = headerPayload.get('svix-id');
  const svix_timestamp = headerPayload.get('svix-timestamp');
  const svix_signature = headerPayload.get('svix-signature');

  if (!svix_id || !svix_timestamp || !svix_signature) {
    return new Response('Missing svix headers', { status: 400 });
  }

  // 페이로드 가져오기
  const payload = await req.json();
  const body = JSON.stringify(payload);

  // Webhook 검증
  const wh = new Webhook(WEBHOOK_SECRET);
  let evt: WebhookEvent;

  try {
    evt = wh.verify(body, {
      'svix-id': svix_id,
      'svix-timestamp': svix_timestamp,
      'svix-signature': svix_signature,
    }) as WebhookEvent;
  } catch (err) {
    console.error('Webhook 검증 실패:', err);
    return new Response('Webhook verification failed', { status: 400 });
  }

  const supabase = createAdminClient();

  // user.created 이벤트 처리
  if (evt.type === 'user.created') {
    const { id, email_addresses, first_name, last_name } = evt.data;
    const email = email_addresses[0]?.email_address;
    const name = [last_name, first_name].filter(Boolean).join('') || email?.split('@')[0] || 'Unknown';

    // @ts-ignore - Supabase type inference issue
    const { error } = await supabase.from('users').insert([{
      id,
      email: email || '',
      name,
    }]);

    if (error) {
      console.error('사용자 생성 실패:', error);
      return new Response('User creation failed', { status: 500 });
    }
  }

  // user.updated 이벤트 처리
  if (evt.type === 'user.updated') {
    const { id, email_addresses, first_name, last_name } = evt.data;
    const email = email_addresses[0]?.email_address;
    const name = [last_name, first_name].filter(Boolean).join('') || email?.split('@')[0] || 'Unknown';

    // @ts-ignore - Supabase type inference issue
    const { error } = await supabase
      .from('users')
      // @ts-ignore - Supabase type inference issue
      .update({
        email: email || '',
        name,
      })
      .eq('id', id);

    if (error) {
      console.error('사용자 업데이트 실패:', error);
      return new Response('User update failed', { status: 500 });
    }
  }

  return new Response('Webhook processed', { status: 200 });
}
</file>

<file path="src/app/dashboard/results/[id]/page.tsx">
import { getSajuTest } from '@/features/saju/queries/get-saju-test';
import { notFound } from 'next/navigation';
import { ResultDetailClient } from '@/features/saju/components/result-detail-client';

type PageProps = {
  params: Promise<{ id: string }>;
};

export default async function ResultDetailPage({ params }: PageProps) {
  const { id } = await params;

  const sajuTest = await getSajuTest(id);

  if (!sajuTest) {
    notFound();
  }

  return <ResultDetailClient sajuTest={sajuTest} />;
}
</file>

<file path="src/app/example/page.tsx">
'use client';

import { ExampleStatus } from '@/features/example/components/example-status';

export default function ExamplePage() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 px-6 py-16 text-slate-100">
      <ExampleStatus />
    </div>
  );
}
</file>

<file path="src/backend/config/index.ts">
import { z } from 'zod';
import type { AppConfig } from '@/backend/hono/context';

const envSchema = z.object({
  SUPABASE_URL: z.string().url(),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),
});

let cachedConfig: AppConfig | null = null;

export const getAppConfig = (): AppConfig => {
  if (cachedConfig) {
    return cachedConfig;
  }

  const parsed = envSchema.safeParse({
    SUPABASE_URL: process.env.SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
  });

  if (!parsed.success) {
    const messages = parsed.error.issues
      .map((issue) => `${issue.path.join('.') || 'config'}: ${issue.message}`)
      .join('; ');
    throw new Error(`Invalid backend configuration: ${messages}`);
  }

  cachedConfig = {
    supabase: {
      url: parsed.data.SUPABASE_URL,
      serviceRoleKey: parsed.data.SUPABASE_SERVICE_ROLE_KEY,
    },
  } satisfies AppConfig;

  return cachedConfig;
};
</file>

<file path="src/backend/hono/app.ts">
import { Hono } from 'hono';
import { errorBoundary } from '@/backend/middleware/error';
import { withAppContext } from '@/backend/middleware/context';
import { withSupabase } from '@/backend/middleware/supabase';
import { registerExampleRoutes } from '@/features/example/backend/route';
import type { AppEnv } from '@/backend/hono/context';

let singletonApp: Hono<AppEnv> | null = null;

export const createHonoApp = () => {
  if (singletonApp) {
    return singletonApp;
  }

  const app = new Hono<AppEnv>();

  app.use('*', errorBoundary());
  app.use('*', withAppContext());
  app.use('*', withSupabase());

  registerExampleRoutes(app);

  singletonApp = app;

  return app;
};
</file>

<file path="src/backend/hono/context.ts">
import type { Context } from 'hono';
import type { SupabaseClient } from '@supabase/supabase-js';

export type AppLogger = Pick<Console, 'info' | 'error' | 'warn' | 'debug'>;

export type AppConfig = {
  supabase: {
    url: string;
    serviceRoleKey: string;
  };
};

export type AppVariables = {
  supabase: SupabaseClient;
  logger: AppLogger;
  config: AppConfig;
};

export type AppEnv = {
  Variables: AppVariables;
};

export type AppContext = Context<AppEnv>;

export const contextKeys = {
  supabase: 'supabase',
  logger: 'logger',
  config: 'config',
} as const satisfies Record<keyof AppVariables, keyof AppVariables>;

export const getSupabase = (c: AppContext) =>
  c.get(contextKeys.supabase) as SupabaseClient;

export const getLogger = (c: AppContext) =>
  c.get(contextKeys.logger) as AppLogger;

export const getConfig = (c: AppContext) =>
  c.get(contextKeys.config) as AppConfig;
</file>

<file path="src/backend/http/response.ts">
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import type { AppContext } from '@/backend/hono/context';

export type SuccessResult<TData> = {
  ok: true;
  status: ContentfulStatusCode;
  data: TData;
};

export type ErrorResult<TCode extends string, TDetails = unknown> = {
  ok: false;
  status: ContentfulStatusCode;
  error: {
    code: TCode;
    message: string;
    details?: TDetails;
  };
};

export type HandlerResult<TData, TCode extends string, TDetails = unknown> =
  | SuccessResult<TData>
  | ErrorResult<TCode, TDetails>;

export const success = <TData>(
  data: TData,
  status: ContentfulStatusCode = 200,
): SuccessResult<TData> => ({
  ok: true,
  status,
  data,
});

export const failure = <TCode extends string, TDetails = unknown>(
  status: ContentfulStatusCode,
  code: TCode,
  message: string,
  details?: TDetails,
): ErrorResult<TCode, TDetails> => ({
  ok: false,
  status,
  error: {
    code,
    message,
    ...(details === undefined ? {} : { details }),
  },
});

export const respond = <TData, TCode extends string, TDetails = unknown>(
  c: AppContext,
  result: HandlerResult<TData, TCode, TDetails>,
) => {
  if (result.ok) {
    return c.json(result.data, result.status);
  }

  const errorResult = result as ErrorResult<TCode, TDetails>;

  return c.json(
    {
      error: errorResult.error,
    },
    errorResult.status,
  );
};
</file>

<file path="src/backend/middleware/context.ts">
import { createMiddleware } from 'hono/factory';
import { getAppConfig } from '@/backend/config';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

const logger: AppLogger = {
  info: (...args) => console.info(...args),
  error: (...args) => console.error(...args),
  warn: (...args) => console.warn(...args),
  debug: (...args) => console.debug(...args),
};

export const withAppContext = () => {
  const config = getAppConfig();

  return createMiddleware<AppEnv>(async (c, next) => {
    c.set(contextKeys.logger, logger);
    c.set(contextKeys.config, config);

    await next();
  });
};
</file>

<file path="src/backend/middleware/error.ts">
import { createMiddleware } from 'hono/factory';
import { match, P } from 'ts-pattern';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

export const errorBoundary = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    try {
      await next();
    } catch (error) {
      const logger = c.get(contextKeys.logger) as AppLogger | undefined;
      const message = match(error)
        .with(P.instanceOf(Error), (err) => err.message)
        .otherwise(() => 'Unexpected error');

      logger?.error?.(error);

      return c.json(
        {
          error: {
            code: 'INTERNAL_SERVER_ERROR',
            message,
          },
        },
        500,
      );
    }
  });
</file>

<file path="src/backend/middleware/supabase.ts">
import { createMiddleware } from 'hono/factory';
import {
  contextKeys,
  type AppEnv,
} from '@/backend/hono/context';
import { createServiceClient } from '@/backend/supabase/client';

export const withSupabase = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    const config = c.get(
      contextKeys.config,
    ) as AppEnv['Variables']['config'] | undefined;

    if (!config) {
      throw new Error('Application configuration is not available.');
    }

    const client = createServiceClient(config.supabase);

    c.set(contextKeys.supabase, client);

    await next();
  });
</file>

<file path="src/backend/supabase/client.ts">
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';

export type ServiceClientConfig = {
  url: string;
  serviceRoleKey: string;
};

export const createServiceClient = ({
  url,
  serviceRoleKey,
}: ServiceClientConfig): SupabaseClient =>
  createClient(url, serviceRoleKey, {
    auth: {
      persistSession: false,
    },
  });
</file>

<file path="src/components/home/feature-card.tsx">
import { type LucideIcon } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';

type FeatureCardProps = {
  icon: LucideIcon;
  title: string;
  description: string;
};

export function FeatureCard({ icon: Icon, title, description }: FeatureCardProps) {
  return (
    <Card className="transition-shadow hover:shadow-lg">
      <CardContent className="flex flex-col items-center p-6 text-center">
        <div className="mb-4 rounded-full bg-indigo-100 p-4">
          <Icon className="h-8 w-8 text-indigo-600" />
        </div>
        <h3 className="mb-2 text-xl font-semibold text-gray-900">{title}</h3>
        <p className="text-gray-600">{description}</p>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/home/footer.tsx">
export function Footer() {
  return (
    <footer className="border-t bg-gray-50 px-6 py-8">
      <div className="mx-auto max-w-7xl">
        <div className="flex flex-col items-center justify-center space-y-4 text-center">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">Vibe Fortune</h3>
            <p className="mt-1 text-sm text-gray-600">AI 기반 사주분석 서비스</p>
          </div>
          <p className="text-sm text-gray-500">
            © 2025 Vibe Fortune. All rights reserved.
          </p>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="src/components/home/pricing-card.tsx">
'use client';

import { Check } from 'lucide-react';
import Link from 'next/link';
import { SignInButton, SignedIn, SignedOut } from '@clerk/nextjs';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

type PricingCardProps = {
  title: string;
  price: string;
  description: string;
  features: string[];
  ctaText: string;
  ctaLink?: string;
  isPopular?: boolean;
  isPro?: boolean;
};

export function PricingCard({
  title,
  price,
  description,
  features,
  ctaText,
  ctaLink,
  isPopular = false,
  isPro = false,
}: PricingCardProps) {
  return (
    <Card
      className={`relative flex flex-col ${
        isPopular ? 'border-2 border-indigo-500 shadow-xl' : 'border shadow-md'
      }`}
    >
      {isPopular && (
        <div className="absolute -top-4 left-1/2 -translate-x-1/2">
          <Badge className="bg-indigo-600 px-4 py-1 text-sm">인기</Badge>
        </div>
      )}
      <CardHeader className="text-center">
        <CardTitle className="text-2xl font-bold">{title}</CardTitle>
        <div className="mt-4">
          <span className="text-4xl font-bold">{price}</span>
          {isPro && <span className="text-gray-500 ml-2">/월</span>}
        </div>
        <CardDescription className="mt-2">{description}</CardDescription>
      </CardHeader>
      <CardContent className="flex-1">
        <ul className="space-y-3">
          {features.map((feature, index) => (
            <li key={index} className="flex items-start gap-3">
              <div className="flex-shrink-0 mt-0.5">
                <Check className="h-5 w-5 text-green-600" />
              </div>
              <span className="text-gray-700">{feature}</span>
            </li>
          ))}
        </ul>
      </CardContent>
      <CardFooter>
        {isPro ? (
          <>
            <SignedOut>
              <SignInButton mode="modal">
                <Button size="lg" className="w-full">
                  {ctaText}
                </Button>
              </SignInButton>
            </SignedOut>
            <SignedIn>
              <Link href={ctaLink || '/subscription'} className="w-full">
                <Button size="lg" className="w-full">
                  {ctaText}
                </Button>
              </Link>
            </SignedIn>
          </>
        ) : (
          <>
            <SignedOut>
              <SignInButton mode="modal">
                <Button size="lg" variant="outline" className="w-full">
                  {ctaText}
                </Button>
              </SignInButton>
            </SignedOut>
            <SignedIn>
              <Link href={ctaLink || '/dashboard'} className="w-full">
                <Button size="lg" variant="outline" className="w-full">
                  {ctaText}
                </Button>
              </Link>
            </SignedIn>
          </>
        )}
      </CardFooter>
    </Card>
  );
}
</file>

<file path="src/components/layout/dashboard-sidebar.tsx">
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { cn } from '@/lib/utils';
import { formatDate } from '@/lib/utils/date';
import { Home, PlusCircle, CreditCard } from 'lucide-react';

type DashboardSidebarProps = {
  userEmail: string;
  subscriptionStatus: 'free' | 'pro' | 'cancelled' | 'payment_failed';
  testCount: number;
  nextBillingDate: string | null;
};

const navItems = [
  { label: '대시보드', href: '/dashboard', icon: Home },
  { label: '새 검사', href: '/dashboard/new', icon: PlusCircle },
  { label: '구독 관리', href: '/subscription', icon: CreditCard },
];

const subscriptionLabels = {
  free: '무료 요금제',
  pro: 'Pro 요금제',
  cancelled: 'Pro (취소 예약)',
  payment_failed: '결제 실패',
};

const subscriptionVariants = {
  free: 'secondary',
  pro: 'default',
  cancelled: 'outline',
  payment_failed: 'destructive',
} as const;

export function DashboardSidebar({
  userEmail,
  subscriptionStatus,
  testCount,
  nextBillingDate,
}: DashboardSidebarProps) {
  const pathname = usePathname();

  return (
    <aside className="w-64 border-r bg-muted/10 p-6 hidden lg:block">
      <div className="mb-6">
        <p className="text-sm text-muted-foreground truncate" title={userEmail}>
          {userEmail}
        </p>
      </div>

      <Separator className="mb-6" />

      <div className="mb-6 space-y-3">
        <div>
          <p className="text-xs text-muted-foreground mb-1">요금제</p>
          <Badge variant={subscriptionVariants[subscriptionStatus]}>
            {subscriptionLabels[subscriptionStatus]}
          </Badge>
        </div>

        <div>
          <p className="text-xs text-muted-foreground mb-1">잔여 검사 횟수</p>
          <p className="text-2xl font-bold">{testCount}회</p>
        </div>

        {nextBillingDate && (
          <div>
            <p className="text-xs text-muted-foreground mb-1">
              {subscriptionStatus === 'cancelled' ? '해지 예정일' : '다음 결제일'}
            </p>
            <p className="text-sm">{formatDate(nextBillingDate, 'yyyy-MM-dd')}</p>
          </div>
        )}

        {subscriptionStatus === 'payment_failed' && (
          <p className="text-xs text-destructive">
            결제 실패. 구독 관리 페이지에서 확인하세요.
          </p>
        )}
      </div>

      <Separator className="mb-6" />

      <nav className="space-y-2">
        {navItems.map((item) => {
          const Icon = item.icon;
          const isActive = pathname === item.href;
          return (
            <Link
              key={item.href}
              href={item.href}
              className={cn(
                'flex items-center gap-3 px-3 py-2 rounded-md text-sm font-medium transition-colors',
                isActive
                  ? 'bg-primary text-primary-foreground'
                  : 'hover:bg-accent hover:text-accent-foreground'
              )}
            >
              <Icon className="h-4 w-4" />
              {item.label}
            </Link>
          );
        })}
      </nav>
    </aside>
  );
}
</file>

<file path="src/components/layout/mobile-sidebar.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { formatDate } from '@/lib/utils/date';
import { Home, PlusCircle, CreditCard, Menu } from 'lucide-react';

type MobileSidebarProps = {
  userEmail: string;
  subscriptionStatus: 'free' | 'pro' | 'cancelled' | 'payment_failed';
  testCount: number;
  nextBillingDate: string | null;
};

const navItems = [
  { label: '대시보드', href: '/dashboard', icon: Home },
  { label: '새 검사', href: '/dashboard/new', icon: PlusCircle },
  { label: '구독 관리', href: '/subscription', icon: CreditCard },
];

const subscriptionLabels = {
  free: '무료 요금제',
  pro: 'Pro 요금제',
  cancelled: 'Pro (취소 예약)',
  payment_failed: '결제 실패',
};

const subscriptionVariants = {
  free: 'secondary',
  pro: 'default',
  cancelled: 'outline',
  payment_failed: 'destructive',
} as const;

export function MobileSidebar({
  userEmail,
  subscriptionStatus,
  testCount,
  nextBillingDate,
}: MobileSidebarProps) {
  const [open, setOpen] = useState(false);
  const pathname = usePathname();

  return (
    <div className="lg:hidden fixed bottom-4 right-4 z-50">
      <Sheet open={open} onOpenChange={setOpen}>
        <SheetTrigger asChild>
          <Button size="icon" className="rounded-full shadow-lg h-14 w-14">
            <Menu className="h-6 w-6" />
          </Button>
        </SheetTrigger>
        <SheetContent side="left" className="w-[300px] sm:w-[350px]">
          <div className="mb-6">
            <p className="text-sm text-muted-foreground truncate" title={userEmail}>
              {userEmail}
            </p>
          </div>

          <Separator className="mb-6" />

          <div className="mb-6 space-y-3">
            <div>
              <p className="text-xs text-muted-foreground mb-1">요금제</p>
              <Badge variant={subscriptionVariants[subscriptionStatus]}>
                {subscriptionLabels[subscriptionStatus]}
              </Badge>
            </div>

            <div>
              <p className="text-xs text-muted-foreground mb-1">잔여 검사 횟수</p>
              <p className="text-2xl font-bold">{testCount}회</p>
            </div>

            {nextBillingDate && (
              <div>
                <p className="text-xs text-muted-foreground mb-1">
                  {subscriptionStatus === 'cancelled' ? '해지 예정일' : '다음 결제일'}
                </p>
                <p className="text-sm">{formatDate(nextBillingDate, 'yyyy-MM-dd')}</p>
              </div>
            )}

            {subscriptionStatus === 'payment_failed' && (
              <p className="text-xs text-destructive">
                결제 실패. 구독 관리 페이지에서 확인하세요.
              </p>
            )}
          </div>

          <Separator className="mb-6" />

          <nav className="space-y-2">
            {navItems.map((item) => {
              const Icon = item.icon;
              const isActive = pathname === item.href;
              return (
                <Link
                  key={item.href}
                  href={item.href}
                  onClick={() => setOpen(false)}
                  className={cn(
                    'flex items-center gap-3 px-3 py-2 rounded-md text-sm font-medium transition-colors',
                    isActive
                      ? 'bg-primary text-primary-foreground'
                      : 'hover:bg-accent hover:text-accent-foreground'
                  )}
                >
                  <Icon className="h-4 w-4" />
                  {item.label}
                </Link>
              );
            })}
          </nav>
        </SheetContent>
      </Sheet>
    </div>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert-dialog.tsx">
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        Chevron: ({ orientation }) =>
          orientation === 'left' ? (
            <ChevronLeft className="h-4 w-4" />
          ) : (
            <ChevronRight className="h-4 w-4" />
          ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-xs",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/date-picker.tsx">
'use client';

import * as React from 'react';
import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import { Calendar as CalendarIcon } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Calendar } from '@/components/ui/calendar';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';

type DatePickerProps = {
  value?: Date;
  onChange?: (date: Date | undefined) => void;
  placeholder?: string;
  disabled?: boolean;
};

export function DatePicker({
  value,
  onChange,
  placeholder = '날짜를 선택하세요',
  disabled,
}: DatePickerProps) {
  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          disabled={disabled}
          className={cn(
            'w-full justify-start text-left font-normal',
            !value && 'text-muted-foreground'
          )}
        >
          <CalendarIcon className="mr-2 h-4 w-4" />
          {value ? format(value, 'PPP', { locale: ko }) : placeholder}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0">
        <Calendar
          mode="single"
          selected={value}
          onSelect={onChange}
          locale={ko}
          disabled={(date) =>
            date > new Date() || date < new Date('1900-01-01')
          }
          initialFocus
        />
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/empty-state.tsx">
import { FileQuestion } from 'lucide-react';
import { Button } from '@/components/ui/button';

type EmptyStateProps = {
  title: string;
  description: string;
  actionLabel?: string;
  onAction?: () => void;
};

export function EmptyState({
  title,
  description,
  actionLabel,
  onAction,
}: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center justify-center py-12 text-center">
      <FileQuestion className="h-16 w-16 text-muted-foreground mb-4" />
      <h3 className="text-lg font-semibold mb-2">{title}</h3>
      <p className="text-sm text-muted-foreground mb-6 max-w-sm">
        {description}
      </p>
      {actionLabel && onAction && (
        <Button onClick={onAction}>{actionLabel}</Button>
      )}
    </div>
  );
}
</file>

<file path="src/components/ui/file-upload.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ChangeEvent, useRef } from "react";

interface FileUploadProps extends React.HTMLAttributes<HTMLDivElement> {
  onFileChange: (file: File) => void;
  accept?: string;
}

export function FileUpload({
  className,
  onFileChange,
  accept = "image/*",
  children,
  ...props
}: FileUploadProps) {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    inputRef.current?.click();
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      onFileChange(file);
    }
  };

  return (
    <div
      onClick={handleClick}
      className={cn(
        "cursor-pointer rounded-md border-2 border-dashed border-gray-300 p-4 hover:border-gray-400",
        className
      )}
      {...props}
    >
      <input
        type="file"
        ref={inputRef}
        onChange={handleChange}
        accept={accept}
        className="hidden"
      />
      {children}
    </div>
  );
}
</file>

<file path="src/components/ui/form.tsx">
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/select.tsx">
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-(--radix-select-trigger-height) w-full min-w-(--radix-select-trigger-width)',
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-px w-full" : "h-full w-px",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
</file>

<file path="src/components/ui/spinner.tsx">
import { Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';

type SpinnerProps = {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
};

export function Spinner({ className, size = 'md' }: SpinnerProps) {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-8 w-8',
    lg: 'h-12 w-12',
  };

  return (
    <Loader2
      className={cn('animate-spin text-primary', sizeClasses[size], className)}
    />
  );
}
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<'textarea'>
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = 'Textarea';

export { Textarea };
</file>

<file path="src/components/ui/time-picker.tsx">
'use client';

import * as React from 'react';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';

type TimePickerProps = {
  value?: string;
  onChange?: (time: string) => void;
  disabled?: boolean;
};

export function TimePicker({ value, onChange, disabled }: TimePickerProps) {
  const [hour, setHour] = React.useState('');
  const [minute, setMinute] = React.useState('');

  React.useEffect(() => {
    if (value) {
      const [h, m] = value.split(':');
      setHour(h || '');
      setMinute(m || '');
    }
  }, [value]);

  const handleHourChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const val = e.target.value.replace(/\D/g, '').slice(0, 2);
    const numVal = parseInt(val, 10);

    if (val === '' || (numVal >= 0 && numVal <= 23)) {
      setHour(val);
      if (val.length === 2 && minute) {
        onChange?.(`${val.padStart(2, '0')}:${minute.padStart(2, '0')}`);
      }
    }
  };

  const handleMinuteChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const val = e.target.value.replace(/\D/g, '').slice(0, 2);
    const numVal = parseInt(val, 10);

    if (val === '' || (numVal >= 0 && numVal <= 59)) {
      setMinute(val);
      if (hour && val.length === 2) {
        onChange?.(`${hour.padStart(2, '0')}:${val.padStart(2, '0')}`);
      }
    }
  };

  return (
    <div className="flex items-center gap-2">
      <div className="flex items-center gap-1">
        <Input
          type="text"
          placeholder="00"
          value={hour}
          onChange={handleHourChange}
          disabled={disabled}
          className="w-16 text-center"
          maxLength={2}
        />
        <Label>시</Label>
      </div>
      <span className="text-muted-foreground">:</span>
      <div className="flex items-center gap-1">
        <Input
          type="text"
          placeholder="00"
          value={minute}
          onChange={handleMinuteChange}
          disabled={disabled}
          className="w-16 text-center"
          maxLength={2}
        />
        <Label>분</Label>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ui/toast.tsx">
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-100 flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-(--radix-toast-swipe-end-x) data-[swipe=move]:translate-x-(--radix-toast-swipe-move-x) data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive',
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600',
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="src/components/ui/toaster.tsx">
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="src/components/markdown-renderer.tsx">
'use client';

import ReactMarkdown from 'react-markdown';

type MarkdownRendererProps = {
  content: string;
};

export function MarkdownRenderer({ content }: MarkdownRendererProps) {
  return (
    <div className="prose prose-slate max-w-none">
      <ReactMarkdown>{content}</ReactMarkdown>
    </div>
  );
}
</file>

<file path="src/constants/auth.ts">
import { match } from "ts-pattern";

const PUBLIC_PATHS = ["/", "/login", "/signup"] as const;
const PUBLIC_PREFIXES = ["/_next", "/api", "/favicon", "/static", "/docs", "/images"] as const;

export const LOGIN_PATH = "/login";
export const SIGNUP_PATH = "/signup";
export const AUTH_ENTRY_PATHS = [LOGIN_PATH, SIGNUP_PATH] as const;
export const isAuthEntryPath = (
  pathname: string
): pathname is (typeof AUTH_ENTRY_PATHS)[number] =>
  AUTH_ENTRY_PATHS.includes(pathname as (typeof AUTH_ENTRY_PATHS)[number]);

export const isAuthPublicPath = (pathname: string) => {
  const normalized = pathname.toLowerCase();

  return match(normalized)
    .when(
      (path) => PUBLIC_PATHS.some((publicPath) => publicPath === path),
      () => true
    )
    .when(
      (path) => PUBLIC_PREFIXES.some((prefix) => path.startsWith(prefix)),
      () => true
    )
    .otherwise(() => false);
};

export const shouldProtectPath = (pathname: string) => !isAuthPublicPath(pathname);
</file>

<file path="src/features/auth/hooks/useCurrentUser.ts">
"use client";

import { useMemo } from "react";
import { useCurrentUserContext } from "../context/current-user-context";

export const useCurrentUser = () => {
  const context = useCurrentUserContext();

  return useMemo(
    () => ({
      user: context.user,
      status: context.status,
      isAuthenticated: context.isAuthenticated,
      isLoading: context.isLoading,
      refresh: context.refresh,
    }),
    [context]
  );
};
</file>

<file path="src/features/auth/types.ts">
export type CurrentUser = {
  id: string;
  email: string | null;
  appMetadata: Record<string, unknown>;
  userMetadata: Record<string, unknown>;
};

export type CurrentUserSnapshot =
  | { status: "authenticated"; user: CurrentUser }
  | { status: "unauthenticated"; user: null }
  | { status: "loading"; user: CurrentUser | null };

export type CurrentUserContextValue = CurrentUserSnapshot & {
  refresh: () => Promise<void>;
  isAuthenticated: boolean;
  isLoading: boolean;
};
</file>

<file path="src/features/example/backend/error.ts">
export const exampleErrorCodes = {
  notFound: 'EXAMPLE_NOT_FOUND',
  fetchError: 'EXAMPLE_FETCH_ERROR',
  validationError: 'EXAMPLE_VALIDATION_ERROR',
} as const;

type ExampleErrorValue = (typeof exampleErrorCodes)[keyof typeof exampleErrorCodes];

export type ExampleServiceError = ExampleErrorValue;
</file>

<file path="src/features/example/backend/route.ts">
import type { Hono } from 'hono';
import {
  failure,
  respond,
  type ErrorResult,
} from '@/backend/http/response';
import {
  getLogger,
  getSupabase,
  type AppEnv,
} from '@/backend/hono/context';
import { ExampleParamsSchema } from '@/features/example/backend/schema';
import { getExampleById } from './service';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from './error';

export const registerExampleRoutes = (app: Hono<AppEnv>) => {
  app.get('/example/:id', async (c) => {
    const parsedParams = ExampleParamsSchema.safeParse({ id: c.req.param('id') });

    if (!parsedParams.success) {
      return respond(
        c,
        failure(
          400,
          'INVALID_EXAMPLE_PARAMS',
          'The provided example id is invalid.',
          parsedParams.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    const result = await getExampleById(supabase, parsedParams.data.id);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ExampleServiceError, unknown>;

      if (errorResult.error.code === exampleErrorCodes.fetchError) {
        logger.error('Failed to fetch example', errorResult.error.message);
      }

      return respond(c, result);
    }

    return respond(c, result);
  });
};
</file>

<file path="src/features/example/backend/schema.ts">
import { z } from 'zod';

export const ExampleParamsSchema = z.object({
  id: z.string().uuid({ message: 'Example id must be a valid UUID.' }),
});

export const ExampleResponseSchema = z.object({
  id: z.string().uuid(),
  fullName: z.string(),
  avatarUrl: z.string().url(),
  bio: z.string().nullable(),
  updatedAt: z.string(),
});

export type ExampleResponse = z.infer<typeof ExampleResponseSchema>;

export const ExampleTableRowSchema = z.object({
  id: z.string().uuid(),
  full_name: z.string().nullable(),
  avatar_url: z.string().nullable(),
  bio: z.string().nullable(),
  updated_at: z.string(),
});

export type ExampleRow = z.infer<typeof ExampleTableRowSchema>;
</file>

<file path="src/features/example/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  ExampleResponseSchema,
  ExampleTableRowSchema,
  type ExampleResponse,
  type ExampleRow,
} from '@/features/example/backend/schema';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from '@/features/example/backend/error';

const EXAMPLE_TABLE = 'example';

const fallbackAvatar = (id: string) =>
  `https://picsum.photos/seed/${encodeURIComponent(id)}/200/200`;

export const getExampleById = async (
  client: SupabaseClient,
  id: string,
): Promise<HandlerResult<ExampleResponse, ExampleServiceError, unknown>> => {
  const { data, error } = await client
    .from(EXAMPLE_TABLE)
    .select('id, full_name, avatar_url, bio, updated_at')
    .eq('id', id)
    .maybeSingle<ExampleRow>();

  if (error) {
    return failure(500, exampleErrorCodes.fetchError, error.message);
  }

  if (!data) {
    return failure(404, exampleErrorCodes.notFound, 'Example not found');
  }

  const rowParse = ExampleTableRowSchema.safeParse(data);

  if (!rowParse.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example row failed validation.',
      rowParse.error.format(),
    );
  }

  const mapped = {
    id: rowParse.data.id,
    fullName: rowParse.data.full_name ?? 'Anonymous User',
    avatarUrl:
      rowParse.data.avatar_url ?? fallbackAvatar(rowParse.data.id),
    bio: rowParse.data.bio,
    updatedAt: rowParse.data.updated_at,
  } satisfies ExampleResponse;

  const parsed = ExampleResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example payload failed validation.',
      parsed.error.format(),
    );
  }

  return success(parsed.data);
};
</file>

<file path="src/features/example/components/example-status.tsx">
'use client';

import { useState } from 'react';
import type { FormEvent } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { useExampleQuery } from '@/features/example/hooks/useExampleQuery';

const statusBadge = (
  label: string,
  tone: 'success' | 'error' | 'idle',
) => {
  const toneStyles: Record<typeof tone, string> = {
    success: 'bg-emerald-500/10 text-emerald-300 border-emerald-400/40',
    error: 'bg-rose-500/10 text-rose-300 border-rose-400/40',
    idle: 'bg-slate-500/10 text-slate-200 border-slate-400/30',
  };

  return (
    <span
      className={`inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-medium ${toneStyles[tone]}`}
    >
      {label}
    </span>
  );
};

export const ExampleStatus = () => {
  const [inputValue, setInputValue] = useState('');
  const [exampleId, setExampleId] = useState('');
  const query = useExampleQuery(exampleId);

  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const trimmed = inputValue.trim();

    if (!trimmed) {
      setExampleId('');
      return;
    }

    if (trimmed === exampleId) {
      void query.refetch();
      return;
    }

    setExampleId(trimmed);
  };

  return (
    <section className="mx-auto flex w-full max-w-3xl flex-col gap-6">
      <header className="space-y-2 text-slate-100">
        <h1 className="text-3xl font-semibold tracking-tight">Backend Health Check</h1>
        <p className="text-sm text-slate-300">
          예시 API(`/api/example/:id`)가 정상 동작하는지 확인합니다. Supabase 예시
          레코드의 UUID를 입력하면 React Query를 통해 백엔드 응답을 확인할 수
          있습니다.
        </p>
      </header>

      <form
        onSubmit={handleSubmit}
        className="flex flex-col gap-3 rounded-xl border border-slate-800 bg-slate-950/60 p-4 md:flex-row md:items-center"
      >
        <div className="flex-1 space-y-1">
          <label className="text-xs uppercase tracking-wide text-slate-400">
            Example UUID
          </label>
          <Input
            value={inputValue}
            onChange={(event) => setInputValue(event.target.value)}
            placeholder="00000000-0000-0000-0000-000000000000"
            className="bg-slate-900/70 text-slate-100 placeholder:text-slate-600"
          />
        </div>
        <Button
          type="submit"
          variant="secondary"
          className="mt-2 h-12 rounded-lg border border-slate-600 bg-slate-800 text-slate-100 hover:bg-slate-700 md:mt-6"
        >
          조회하기
        </Button>
      </form>

      <article className="space-y-3 rounded-xl border border-slate-800 bg-slate-950/60 p-6 text-slate-100">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">현재 상태</h2>
          {exampleId
            ? query.status === 'pending'
              ? statusBadge('Fetching', 'idle')
              : query.status === 'error'
                ? statusBadge('Error', 'error')
                : statusBadge('Success', 'success')
            : statusBadge('Idle', 'idle')}
        </div>

        {!exampleId && (
          <p className="text-sm text-slate-300">
            UUID를 입력하고 조회하기 버튼을 누르면 결과가 이곳에 표시됩니다.
          </p>
        )}

        {exampleId && query.status === 'pending' && (
          <p className="text-sm text-slate-300">Supabase에서 데이터를 가져오는 중...</p>
        )}

        {query.status === 'error' && (
          <div className="space-y-2 rounded-lg border border-rose-400/30 bg-rose-500/5 p-4">
            <p className="text-sm font-medium text-rose-300">요청 실패</p>
            <p className="text-xs text-rose-200/80">
              {query.error instanceof Error
                ? query.error.message
                : '알 수 없는 에러가 발생했습니다.'}
            </p>
          </div>
        )}

        {query.data && (
          <div className="space-y-3 rounded-lg border border-emerald-400/30 bg-emerald-500/5 p-4 text-sm text-emerald-100">
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">ID</p>
              <p className="font-mono text-xs md:text-sm">{query.data.id}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                이름
              </p>
              <p>{query.data.fullName}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                소개
              </p>
              <p>{query.data.bio ?? '—'}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                아바타
              </p>
              <a
                href={query.data.avatarUrl}
                target="_blank"
                rel="noreferrer"
                className="underline"
              >
                {query.data.avatarUrl}
              </a>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                업데이트 시각
              </p>
              <p>{query.data.updatedAt}</p>
            </div>
          </div>
        )}
      </article>
    </section>
  );
};
</file>

<file path="src/features/example/hooks/useExampleQuery.ts">
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import { ExampleResponseSchema } from '@/features/example/lib/dto';

const fetchExample = async (id: string) => {
  try {
    const { data } = await apiClient.get(`/api/example/${id}`);
    return ExampleResponseSchema.parse(data);
  } catch (error) {
    const message = extractApiErrorMessage(error, 'Failed to fetch example.');
    throw new Error(message);
  }
};

export const useExampleQuery = (id: string) =>
  useQuery({
    queryKey: ['example', id],
    queryFn: () => fetchExample(id),
    enabled: Boolean(id),
    staleTime: 60 * 1000,
  });
</file>

<file path="src/features/example/lib/dto.ts">
export {
  ExampleParamsSchema,
  ExampleResponseSchema,
  type ExampleResponse,
} from '@/features/example/backend/schema';
</file>

<file path="src/features/saju/actions/delete-saju-test.ts">
/**
 * 사주분석 삭제 Server Action
 *
 * 사용자가 자신의 사주분석 결과를 삭제할 수 있습니다.
 * 삭제 후 대시보드로 리다이렉트됩니다.
 */

'use server';

import { createClient } from '@/lib/supabase/server-client';
import { auth } from '@clerk/nextjs/server';

export async function deleteSajuTest(testId: string) {
  try {
    // 1. 사용자 인증 확인
    const { userId } = await auth();
    if (!userId) {
      return { success: false, error: '인증이 필요합니다.' };
    }

    const supabase = await createClient();

    // 2. 사주분석 존재 여부 및 소유권 확인
    const { data: sajuTest, error: fetchError } = await supabase
      .from('saju_tests')
      .select('id, user_id')
      .eq('id', testId)
      .eq('user_id', userId)
      .single();

    if (fetchError || !sajuTest) {
      return { success: false, error: '사주분석을 찾을 수 없습니다.' };
    }

    // 3. 사주분석 삭제
    const { error: deleteError } = await supabase
      .from('saju_tests')
      .delete()
      .eq('id', testId)
      .eq('user_id', userId);

    if (deleteError) {
      console.error('사주분석 삭제 실패:', deleteError);
      return { success: false, error: '사주분석 삭제에 실패했습니다.' };
    }

    console.log('사주분석 삭제 완료:', { testId, userId });

    // 4. 성공 반환 (리다이렉트는 컴포넌트에서 처리)
    return { success: true };
  } catch (error: any) {
    console.error('사주분석 삭제 실패:', error);
    return { success: false, error: '사주분석 삭제에 실패했습니다.' };
  }
}
</file>

<file path="src/features/saju/components/dashboard-content.tsx">
'use client';

import { useState, useCallback } from 'react';
import Link from 'next/link';
import { SajuTestCard } from './saju-test-card';
import { SearchBar } from './search-bar';
import { LoadMoreButton } from './load-more-button';
import { loadMoreTests } from '@/features/saju/actions/load-more-tests';
import { Button } from '@/components/ui/button';
import { FileQuestion, Search } from 'lucide-react';
import type { SajuTestListItem } from '@/features/saju/types/result';

type DashboardContentProps = {
  initialTests: SajuTestListItem[];
};

export function DashboardContent({ initialTests }: DashboardContentProps) {
  const [tests, setTests] = useState<SajuTestListItem[]>(initialTests);
  const [searchQuery, setSearchQuery] = useState('');
  const [offset, setOffset] = useState(10);
  const [hasMore, setHasMore] = useState(initialTests.length === 10);
  const [isLoading, setIsLoading] = useState(false);

  const filteredTests = tests.filter((test) =>
    test.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleSearch = useCallback((query: string) => {
    setSearchQuery(query);
  }, []);

  const handleLoadMore = async () => {
    setIsLoading(true);
    try {
      const result = await loadMoreTests(offset);
      if (result.success && result.data) {
        setTests((prev) => [...prev, ...result.data!]);
        setOffset((prev) => prev + 10);
        setHasMore(result.hasMore || false);
      }
    } catch (error) {
      console.error('더보기 실패:', error);
    } finally {
      setIsLoading(false);
    }
  };

  if (tests.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12 text-center">
        <FileQuestion className="h-16 w-16 text-muted-foreground mb-4" />
        <h3 className="text-lg font-semibold mb-2">아직 사주분석 이력이 없습니다</h3>
        <p className="text-sm text-muted-foreground mb-6 max-w-sm">
          첫 사주분석을 시작해보세요
        </p>
        <Link href="/dashboard/new">
          <Button>첫 검사 시작하기</Button>
        </Link>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <SearchBar onSearch={handleSearch} />

      {searchQuery && filteredTests.length === 0 ? (
        <div className="flex flex-col items-center justify-center py-12 text-center">
          <Search className="h-16 w-16 text-muted-foreground mb-4" />
          <h3 className="text-lg font-semibold mb-2">검색 결과가 없습니다</h3>
          <p className="text-sm text-muted-foreground mb-6 max-w-sm">
            다른 검색어로 시도해보세요
          </p>
          <Button variant="outline" onClick={() => setSearchQuery('')}>
            검색 초기화
          </Button>
        </div>
      ) : (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {filteredTests.map((test) => (
              <SajuTestCard key={test.id} test={test} />
            ))}
          </div>

          {!searchQuery && hasMore && (
            <div className="flex justify-center">
              <LoadMoreButton
                onLoadMore={handleLoadMore}
                isLoading={isLoading}
                hasMore={hasMore}
              />
            </div>
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="src/features/saju/components/delete-test-dialog.tsx">
/**
 * 사주분석 삭제 확인 다이얼로그
 *
 * 사용자가 사주분석을 삭제하기 전에 확인을 받는 다이얼로그입니다.
 * 삭제는 되돌릴 수 없으므로 신중한 확인이 필요합니다.
 */

'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import { Button } from '@/components/ui/button';
import { Trash2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { deleteSajuTest } from '@/features/saju/actions/delete-saju-test';

interface DeleteTestDialogProps {
  testId: string;
  testName: string;
}

export function DeleteTestDialog({ testId, testName }: DeleteTestDialogProps) {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleDelete = async () => {
    setLoading(true);

    try {
      const result = await deleteSajuTest(testId);
      
      if (result?.success === false) {
        toast({
          variant: 'destructive',
          title: '삭제 실패',
          description: result.error || '사주분석 삭제에 실패했습니다.',
        });
        setLoading(false);
        return;
      }

      // 성공 시 토스트 메시지 및 리다이렉트
      toast({
        title: '삭제 완료',
        description: '사주분석이 삭제되었습니다.',
      });

      setOpen(false);
      
      // 대시보드로 리다이렉트
      router.push('/dashboard');
    } catch (error: any) {
      console.error('사주분석 삭제 실패:', error);
      
      toast({
        variant: 'destructive',
        title: '삭제 실패',
        description: '사주분석 삭제에 실패했습니다. 다시 시도해주세요.',
      });
      
      setLoading(false);
    }
  };

  return (
    <AlertDialog open={open} onOpenChange={setOpen}>
      <AlertDialogTrigger asChild>
        <Button
          variant="outline"
          size="sm"
          className="gap-2 text-destructive hover:text-destructive hover:bg-destructive/10"
          aria-label="사주분석 삭제"
        >
          <Trash2 className="h-4 w-4" />
          검사 삭제
        </Button>
      </AlertDialogTrigger>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>사주분석 삭제</AlertDialogTitle>
          <AlertDialogDescription>
            <strong>"{testName}"</strong> 사주분석을 삭제하시겠습니까?
            <br />
            <br />
            이 작업은 되돌릴 수 없으며, 분석 결과가 영구적으로 삭제됩니다.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={loading}>
            취소
          </AlertDialogCancel>
          <AlertDialogAction
            onClick={handleDelete}
            disabled={loading}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {loading ? '삭제 중...' : '삭제하기'}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="src/features/saju/components/load-more-button.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { Loader2 } from 'lucide-react';

type LoadMoreButtonProps = {
  onLoadMore: () => void;
  isLoading?: boolean;
  hasMore?: boolean;
};

export function LoadMoreButton({ onLoadMore, isLoading = false, hasMore = true }: LoadMoreButtonProps) {
  if (!hasMore) {
    return null;
  }

  return (
    <Button
      onClick={onLoadMore}
      disabled={isLoading}
      variant="outline"
      className="w-full sm:w-auto"
      aria-busy={isLoading}
    >
      {isLoading ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          로딩 중...
        </>
      ) : (
        '더보기'
      )}
    </Button>
  );
}
</file>

<file path="src/features/saju/components/navigation-buttons.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { ArrowLeft, Plus } from 'lucide-react';

export function NavigationButtons() {
  const router = useRouter();

  const handleBackToDashboard = () => {
    router.push('/dashboard');
  };

  const handleNewTest = () => {
    router.push('/dashboard/new');
  };

  return (
    <div className="flex flex-col sm:flex-row gap-4 justify-between">
      <Button
        onClick={handleBackToDashboard}
        variant="outline"
        className="gap-2"
      >
        <ArrowLeft className="h-4 w-4" />
        목록으로
      </Button>

      <Button
        onClick={handleNewTest}
        className="gap-2"
      >
        <Plus className="h-4 w-4" />
        새 검사하기
      </Button>
    </div>
  );
}
</file>

<file path="src/features/saju/components/saju-test-card.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { formatDate } from '@/lib/utils/date';
import type { SajuTestListItem } from '@/features/saju/types/result';

type SajuTestCardProps = {
  test: SajuTestListItem;
};

export function SajuTestCard({ test }: SajuTestCardProps) {
  const router = useRouter();

  const handleClick = () => {
    router.push(`/dashboard/results/${test.id}`);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleClick();
    }
  };

  return (
    <Card
      className="cursor-pointer transition-all hover:shadow-lg hover:bg-accent/50"
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      tabIndex={0}
      role="button"
      aria-label={`${test.name}님의 사주분석 결과, ${formatDate(test.createdAt)}에 생성됨`}
    >
      <CardHeader>
        <CardTitle>{test.name}</CardTitle>
        <CardDescription>
          {formatDate(test.birthDate, 'yyyy-MM-dd')}
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex items-center justify-between">
          <Badge variant={test.gender === 'male' ? 'default' : 'secondary'}>
            {test.gender === 'male' ? '남성' : '여성'}
          </Badge>
          <span className="text-sm text-muted-foreground">
            {formatDate(test.createdAt, 'yyyy년 MM월 dd일')}
          </span>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/saju/components/search-bar.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Search, X } from 'lucide-react';

type SearchBarProps = {
  onSearch: (query: string) => void;
  placeholder?: string;
};

export function SearchBar({ onSearch, placeholder = '검사자 이름으로 검색...' }: SearchBarProps) {
  const [query, setQuery] = useState('');

  useEffect(() => {
    const timer = setTimeout(() => {
      onSearch(query);
    }, 300);

    return () => clearTimeout(timer);
  }, [query, onSearch]);

  const handleClear = () => {
    setQuery('');
  };

  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
      <Input
        type="text"
        placeholder={placeholder}
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        className="pl-10 pr-10"
        aria-label="검사자 이름 검색"
      />
      {query && (
        <Button
          variant="ghost"
          size="icon"
          className="absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7"
          onClick={handleClear}
          aria-label="검색어 지우기"
        >
          <X className="h-4 w-4" />
        </Button>
      )}
    </div>
  );
}
</file>

<file path="src/features/saju/types/input.ts">
import { z } from 'zod';

export const sajuInputSchema = z.object({
  name: z.string().min(1, '성함을 입력해주세요').max(50, '성함은 50자 이하로 입력해주세요'),
  birthDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, '올바른 날짜 형식(YYYY-MM-DD)을 입력해주세요'),
  birthTime: z.string().regex(/^\d{2}:\d{2}$/).nullable().optional(),
  birthTimeUnknown: z.boolean().default(false),
  gender: z.enum(['male', 'female'], {
    errorMap: () => ({ message: '성별을 선택해주세요' }),
  }),
});

export type SajuInput = z.infer<typeof sajuInputSchema>;
</file>

<file path="src/features/subscription/actions/cancel-subscription.ts">
/**
 * 구독 취소 Server Action
 *
 * 사용자의 Pro 구독을 취소 예약합니다.
 * 구독은 즉시 해지되지 않고, 다음 결제일까지 Pro 혜택이 유지됩니다.
 *
 * @returns success: 성공 여부, error: 에러 메시지
 */

'use server';

import { createClient } from '@/lib/supabase/server-client';
import { auth } from '@clerk/nextjs/server';

export async function cancelSubscription() {
  try {
    // 1. 사용자 인증 확인
    const { userId } = await auth();
    if (!userId) {
      return { success: false, error: '인증이 필요합니다.' };
    }

    const supabase = await createClient();

    // 2. 활성 구독 확인
    const { data: subscription, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status')
      .eq('user_id', userId)
      .single();

    if (fetchError || !subscription) {
      return { success: false, error: '활성화된 구독을 찾을 수 없습니다.' };
    }

    if (subscription.status !== 'active') {
      return { success: false, error: '취소할 수 있는 구독이 아닙니다.' };
    }

    // 3. 구독 상태를 cancelled로 변경
    const { error: subError } = await supabase
      .from('subscriptions')
      .update({ status: 'cancelled' })
      .eq('user_id', userId);

    if (subError) {
      console.error('구독 취소 실패:', subError);
      throw subError;
    }

    // 4. users 테이블 업데이트
    const { error: userError } = await supabase
      .from('users')
      .update({ subscription_status: 'cancelled' })
      .eq('id', userId);

    if (userError) {
      console.error('사용자 정보 업데이트 실패:', userError);
      throw userError;
    }

    console.log('구독 취소 완료:', { userId });

    return { success: true };
  } catch (error: any) {
    console.error('구독 취소 실패:', error);
    return { success: false, error: '구독 취소에 실패했습니다.' };
  }
}
</file>

<file path="src/features/subscription/actions/resume-subscription.ts">
/**
 * 구독 재개 Server Action
 *
 * 취소 예약된 구독을 재개합니다.
 * 구독이 해지되기 전에만 재개가 가능합니다.
 *
 * @returns success: 성공 여부, error: 에러 메시지
 */

'use server';

import { createClient } from '@/lib/supabase/server-client';
import { auth } from '@clerk/nextjs/server';

export async function resumeSubscription() {
  try {
    // 1. 사용자 인증 확인
    const { userId } = await auth();
    if (!userId) {
      return { success: false, error: '인증이 필요합니다.' };
    }

    const supabase = await createClient();

    // 2. 취소 예약된 구독 확인
    const { data: subscription, error: fetchError } = await supabase
      .from('subscriptions')
      .select('id, status')
      .eq('user_id', userId)
      .single();

    if (fetchError || !subscription) {
      return { success: false, error: '구독을 찾을 수 없습니다.' };
    }

    if (subscription.status !== 'cancelled') {
      return { success: false, error: '재개할 수 있는 구독이 아닙니다.' };
    }

    // 3. 구독 상태를 active로 변경
    const { error: subError } = await supabase
      .from('subscriptions')
      .update({ status: 'active' })
      .eq('user_id', userId);

    if (subError) {
      console.error('구독 재개 실패:', subError);
      throw subError;
    }

    // 4. users 테이블 업데이트
    const { error: userError } = await supabase
      .from('users')
      .update({ subscription_status: 'pro' })
      .eq('id', userId);

    if (userError) {
      console.error('사용자 정보 업데이트 실패:', userError);
      throw userError;
    }

    console.log('구독 재개 완료:', { userId });

    return { success: true };
  } catch (error: any) {
    console.error('구독 재개 실패:', error);
    return { success: false, error: '구독 재개에 실패했습니다.' };
  }
}
</file>

<file path="src/features/subscription/components/cancel-subscription-dialog.tsx">
/**
 * 구독 취소 확인 다이얼로그
 *
 * 사용자가 구독을 취소할 때 확인 메시지를 표시합니다.
 * - 다음 결제일까지 Pro 혜택 유지 안내
 * - 언제든 재개 가능 안내
 */

'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { cancelSubscription } from '@/features/subscription/actions/cancel-subscription';
import { formatDate } from '@/lib/utils/date';

interface CancelSubscriptionDialogProps {
  nextBillingDate: string | null;
}

export function CancelSubscriptionDialog({ nextBillingDate }: CancelSubscriptionDialogProps) {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleCancel = async () => {
    setLoading(true);

    try {
      const result = await cancelSubscription();

      if (result.success) {
        toast({
          title: '구독이 취소 예약되었습니다',
          description: `${nextBillingDate ? formatDate(nextBillingDate) : '다음 결제일'}까지 Pro 혜택이 유지됩니다.`,
        });

        setOpen(false);
        router.refresh(); // 페이지 리로드로 최신 상태 반영
      } else {
        toast({
          variant: 'destructive',
          title: '구독 취소 실패',
          description: result.error || '일시적인 오류가 발생했습니다. 다시 시도해주세요.',
        });
      }
    } catch (error: any) {
      console.error('구독 취소 실패:', error);
      toast({
        variant: 'destructive',
        title: '구독 취소 실패',
        description: '일시적인 오류가 발생했습니다. 다시 시도해주세요.',
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <AlertDialog open={open} onOpenChange={setOpen}>
      <AlertDialogTrigger asChild>
        <Button variant="destructive">구독 취소</Button>
      </AlertDialogTrigger>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>구독을 취소하시겠습니까?</AlertDialogTitle>
          <AlertDialogDescription className="space-y-2">
            <p>
              다음 결제일({nextBillingDate ? formatDate(nextBillingDate) : '예정일'})까지 Pro 혜택이 유지됩니다.
            </p>
            <p className="text-sm">
              다음 결제일 전까지 언제든지 구독을 재개할 수 있습니다.
            </p>
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={loading}>취소</AlertDialogCancel>
          <AlertDialogAction onClick={handleCancel} disabled={loading}>
            {loading ? '처리 중...' : '확인'}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="src/features/subscription/components/resume-subscription-dialog.tsx">
/**
 * 구독 재개 확인 다이얼로그
 *
 * 취소 예약된 구독을 재개할 때 확인 메시지를 표시합니다.
 * - 다음 결제일 자동 결제 안내
 */

'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { resumeSubscription } from '@/features/subscription/actions/resume-subscription';
import { formatDate } from '@/lib/utils/date';

interface ResumeSubscriptionDialogProps {
  nextBillingDate: string | null;
}

export function ResumeSubscriptionDialog({ nextBillingDate }: ResumeSubscriptionDialogProps) {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleResume = async () => {
    setLoading(true);

    try {
      const result = await resumeSubscription();

      if (result.success) {
        toast({
          title: '구독이 재개되었습니다',
          description: `${nextBillingDate ? formatDate(nextBillingDate) : '다음 결제일'}에 자동 결제가 진행됩니다.`,
        });

        setOpen(false);
        router.refresh(); // 페이지 리로드로 최신 상태 반영
      } else {
        toast({
          variant: 'destructive',
          title: '구독 재개 실패',
          description: result.error || '일시적인 오류가 발생했습니다. 다시 시도해주세요.',
        });
      }
    } catch (error: any) {
      console.error('구독 재개 실패:', error);
      toast({
        variant: 'destructive',
        title: '구독 재개 실패',
        description: '일시적인 오류가 발생했습니다. 다시 시도해주세요.',
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <AlertDialog open={open} onOpenChange={setOpen}>
      <AlertDialogTrigger asChild>
        <Button>구독 재개</Button>
      </AlertDialogTrigger>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>구독을 재개하시겠습니까?</AlertDialogTitle>
          <AlertDialogDescription className="space-y-2">
            <p>
              다음 결제일({nextBillingDate ? formatDate(nextBillingDate) : '예정일'})에 자동 결제가 진행됩니다.
            </p>
            <p className="text-sm">
              월 9,900원이 자동으로 결제됩니다.
            </p>
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={loading}>취소</AlertDialogCancel>
          <AlertDialogAction onClick={handleResume} disabled={loading}>
            {loading ? '처리 중...' : '확인'}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="src/features/subscription/components/subscribe-pro-dialog.tsx">
/**
 * Pro 구독 신청 다이얼로그
 *
 * 토스페이먼츠 SDK를 사용하여 카드 등록 및 빌링키 발급을 진행합니다.
 * - 카드 정보 입력 (토스페이먼츠 UI)
 * - 본인인증
 * - authKey 수신
 * - 서버에서 빌링키 발급 및 첫 결제
 */

'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { requestBillingAuth } from '@/lib/toss-payments';
import { v4 as uuidv4 } from 'uuid';

interface SubscribeProDialogProps {
  customerEmail: string;
  customerName: string;
}

export function SubscribeProDialog({ customerEmail, customerName }: SubscribeProDialogProps) {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [customerKey, setCustomerKey] = useState('');
  const router = useRouter();
  const { toast } = useToast();

  // customerKey 생성 (다이얼로그 열 때마다 새로 생성)
  useEffect(() => {
    if (open) {
      setCustomerKey(uuidv4());
    }
  }, [open]);

  const handleSubscribe = async () => {
    if (!customerKey) {
      toast({
        variant: 'destructive',
        title: '오류',
        description: 'customerKey가 생성되지 않았습니다. 다시 시도해주세요.',
      });
      return;
    }

    setLoading(true);

    try {
      // customerKey를 세션에 임시 저장 (성공 페이지에서 사용)
      sessionStorage.setItem('customerKey', customerKey);

      // 토스페이먼츠 카드 등록 요청
      await requestBillingAuth(customerKey, {
        method: 'CARD',
        successUrl: `${window.location.origin}/subscription/success`,
        failUrl: `${window.location.origin}/subscription/fail`,
        customerEmail,
        customerName,
      });

      // 토스페이먼츠 창이 열리면 로딩 종료
      // 실제 처리는 success 페이지에서 진행
      setLoading(false);
      setOpen(false);
    } catch (error: any) {
      console.error('카드 등록 실패:', error);

      let errorMessage = '카드 등록에 실패했습니다. 다시 시도해주세요.';

      if (error.code === 'USER_CANCEL') {
        errorMessage = '사용자가 결제창을 닫았습니다.';
      } else if (error.code === 'INVALID_CUSTOMER_KEY') {
        errorMessage = 'customerKey 형식 오류입니다.';
      }

      toast({
        variant: 'destructive',
        title: '카드 등록 실패',
        description: errorMessage,
      });

      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button size="lg" className="w-full sm:w-auto">
          Pro 구독하기
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Pro 구독 신청</DialogTitle>
          <DialogDescription>
            월 9,900원으로 매월 10회의 고급 사주 분석을 이용하세요.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="rounded-lg border border-border bg-muted/50 p-4 space-y-2 text-sm">
            <h4 className="font-medium">Pro 혜택</h4>
            <ul className="space-y-1 text-muted-foreground list-disc list-inside">
              <li>월 10회 고급 사주 분석</li>
              <li>Gemini Pro 모델 사용</li>
              <li>더 정확하고 상세한 분석</li>
              <li>직업운 및 월별 운세 포함</li>
            </ul>
          </div>

          <div className="rounded-lg border border-border bg-muted/50 p-4 space-y-2 text-sm">
            <h4 className="font-medium">결제 정보</h4>
            <ul className="space-y-1 text-muted-foreground">
              <li>월 요금: 9,900원</li>
              <li>첫 결제: 즉시 (카드 등록 후)</li>
              <li>다음 결제: 매월 자동 결제</li>
              <li>언제든지 취소 가능</li>
            </ul>
          </div>

          <p className="text-xs text-muted-foreground">
            결제는 토스페이먼츠를 통해 안전하게 처리됩니다.
            카드 등록 후 즉시 첫 결제가 진행됩니다.
          </p>
        </div>

        <DialogFooter className="sm:justify-between">
          <Button
            type="button"
            variant="outline"
            onClick={() => setOpen(false)}
            disabled={loading}
          >
            취소
          </Button>
          <Button
            type="button"
            onClick={handleSubscribe}
            disabled={loading || !customerKey}
          >
            {loading ? '처리 중...' : '카드 등록하기'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/subscription/components/subscription-card.tsx">
/**
 * 구독 정보 카드 컴포넌트
 *
 * 현재 사용자의 구독 정보를 표시합니다:
 * - 이메일
 * - 요금제 (무료/Pro)
 * - 잔여 검사 횟수
 * - 다음 결제일 (Pro인 경우)
 * - 카드 정보 (Pro인 경우)
 */

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { SubscriptionStatus } from './subscription-status';
import { formatDate } from '@/lib/utils/date';
import type { SubscriptionInfo } from '@/features/subscription/queries/get-subscription';
import { CreditCard, Calendar, Hash, AlertCircle } from 'lucide-react';

interface SubscriptionCardProps {
  email: string;
  subscription: SubscriptionInfo;
}

export function SubscriptionCard({ email, subscription }: SubscriptionCardProps) {
  const { status, testCount, nextBillingDate, cardNumber, cardCompany } = subscription;

  // 구독 상태에 따른 설명 메시지
  const getDescription = () => {
    switch (status) {
      case 'free':
        return '무료 요금제를 사용 중입니다. Pro 구독으로 월 10회 고급 분석을 이용하세요!';
      case 'pro':
        return `Pro 구독이 활성화되어 있습니다. 다음 결제일에 자동으로 9,900원이 결제됩니다.`;
      case 'cancelled':
        return `구독이 취소 예약되었습니다. ${nextBillingDate ? formatDate(nextBillingDate) : '다음 결제일'}까지 Pro 혜택이 유지됩니다.`;
      case 'payment_failed':
        return '결제에 실패했습니다. 카드 한도 초과 또는 잔액 부족일 수 있습니다. 3일 후 자동으로 재시도되며, 실패 시 구독이 자동 해지됩니다.';
      default:
        return '';
    }
  };

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>구독 정보</CardTitle>
          <SubscriptionStatus status={status} />
        </div>
        <CardDescription>{getDescription()}</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* 이메일 */}
        <div className="flex items-center gap-2 text-sm">
          <span className="text-muted-foreground">이메일:</span>
          <span className="font-medium">{email}</span>
        </div>

        {/* 요금제 */}
        <div className="flex items-center gap-2 text-sm">
          <span className="text-muted-foreground">현재 요금제:</span>
          <span className="font-medium">
            {status === 'free' ? '무료' : status === 'cancelled' ? 'Pro (취소 예약)' : status === 'payment_failed' ? 'Pro (결제 실패)' : 'Pro'}
          </span>
        </div>

        {/* 잔여 횟수 */}
        <div className="flex items-center gap-2 text-sm">
          <Hash className="h-4 w-4 text-muted-foreground" />
          <span className="text-muted-foreground">잔여 검사 횟수:</span>
          <span className="font-medium">
            {testCount}회{status !== 'free' && ' / 월 10회'}
          </span>
        </div>

        {/* 다음 결제일 (Pro인 경우) */}
        {nextBillingDate && (status === 'pro' || status === 'cancelled' || status === 'payment_failed') && (
          <div className="flex items-center gap-2 text-sm">
            <Calendar className="h-4 w-4 text-muted-foreground" />
            <span className="text-muted-foreground">
              {status === 'cancelled' ? '해지 예정일:' : '다음 결제일:'}
            </span>
            <span className="font-medium">{formatDate(nextBillingDate)}</span>
          </div>
        )}

        {/* 카드 정보 (Pro인 경우) */}
        {cardNumber && cardCompany && (status === 'pro' || status === 'cancelled' || status === 'payment_failed') && (
          <div className="flex items-center gap-2 text-sm">
            <CreditCard className="h-4 w-4 text-muted-foreground" />
            <span className="text-muted-foreground">카드 정보:</span>
            <span className="font-medium">
              {cardCompany} **** **** **** {cardNumber}
            </span>
          </div>
        )}

        {/* 경고 메시지 (결제 실패) */}
        {status === 'payment_failed' && (
          <div className="flex gap-2 rounded-md border border-destructive/50 bg-destructive/10 p-3 text-sm text-destructive">
            <AlertCircle className="h-4 w-4 flex-shrink-0 mt-0.5" />
            <div>
              <p className="font-medium">결제 실패</p>
              <p className="mt-1 text-xs">
                카드 한도를 확인하고 결제 재시도를 눌러주세요.
              </p>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/subscription/components/subscription-status.tsx">
/**
 * 구독 상태 배지 컴포넌트
 *
 * 사용자의 구독 상태를 시각적으로 표시합니다.
 */

import { Badge } from '@/components/ui/badge';

interface SubscriptionStatusProps {
  status: 'free' | 'pro' | 'cancelled' | 'payment_failed';
}

export function SubscriptionStatus({ status }: SubscriptionStatusProps) {
  const statusConfig = {
    free: {
      label: '무료',
      variant: 'secondary' as const,
    },
    pro: {
      label: 'Pro',
      variant: 'default' as const,
    },
    cancelled: {
      label: '취소 예약',
      variant: 'outline' as const,
    },
    payment_failed: {
      label: '결제 실패',
      variant: 'destructive' as const,
    },
  };

  const config = statusConfig[status];

  return (
    <Badge variant={config.variant} className="text-xs">
      {config.label}
    </Badge>
  );
}
</file>

<file path="src/hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/lib/gemini/client.ts">
import { serverEnv } from '@/constants/server-env';
import 'server-only';

export type GeminiResponse = {
  text: string;
};

export class GeminiClient {
  private readonly apiKey: string;
  private readonly baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  private readonly model = 'gemini-2.0-flash-exp';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async generateContent(prompt: string): Promise<GeminiResponse> {
    const url = `${this.baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: prompt,
              },
            ],
          },
        ],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 4096,
        },
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Gemini API 호출 실패: ${response.status} - ${error}`);
    }

    const data = await response.json();
    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!text) {
      throw new Error('Gemini API 응답 형식이 올바르지 않습니다');
    }

    return { text };
  }
}

export const geminiClient = new GeminiClient(serverEnv.GEMINI_API_KEY);
</file>

<file path="src/lib/remote/api-client.ts">
import axios, { isAxiosError } from "axios";

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL ?? "",
  headers: {
    "Content-Type": "application/json",
  },
});

type ErrorPayload = {
  error?: {
    message?: string;
  };
  message?: string;
};

export const extractApiErrorMessage = (
  error: unknown,
  fallbackMessage = "API request failed."
) => {
  if (isAxiosError(error)) {
    const payload = error.response?.data as ErrorPayload | undefined;

    if (typeof payload?.error?.message === "string") {
      return payload.error.message;
    }

    if (typeof payload?.message === "string") {
      return payload.message;
    }
  }

  if (error instanceof Error && error.message) {
    return error.message;
  }

  return fallbackMessage;
};

export { apiClient, isAxiosError };
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
</file>

<file path="src/lib/supabase/server.ts">
import "server-only";

import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}

export async function createPureClient() {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return [];
        },
        setAll() {},
      },
    }
  );
}
</file>

<file path="src/lib/toss-payments/api.ts">
/**
 * 토스페이먼츠 API 유틸리티 함수 (Server-side only)
 *
 * 빌링키 발급, 자동결제 승인, 빌링키 삭제 등의 서버 사이드 API 호출을 담당합니다.
 *
 * @see https://docs.tosspayments.com/guides/v2/billing
 */

import { serverEnv } from '@/constants/server-env';
import 'server-only';

const TOSS_API_BASE_URL = 'https://api.tosspayments.com/v1';

/**
 * 토스페이먼츠 API 에러
 */
export class TossPaymentsError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number
  ) {
    super(message);
    this.name = 'TossPaymentsError';
  }
}

/**
 * 시크릿 키를 Base64로 인코딩합니다.
 *
 * 토스페이먼츠 API는 Basic 인증을 사용하며,
 * "시크릿키:" 형식으로 인코딩해야 합니다.
 *
 * @returns Base64 인코딩된 시크릿 키
 * @throws 시크릿 키가 설정되지 않은 경우 에러 발생
 */
function getEncodedSecretKey(): string {
  if (!serverEnv.TOSS_SECRET_KEY) {
    throw new Error('TOSS_SECRET_KEY가 설정되지 않았습니다.');
  }

  return Buffer.from(`${serverEnv.TOSS_SECRET_KEY}:`).toString('base64');
}

/**
 * 토스페이먼츠 API를 호출합니다.
 *
 * @param endpoint - API 엔드포인트 (예: '/billing/authorizations/issue')
 * @param options - fetch 옵션
 * @returns API 응답 데이터
 * @throws API 호출 실패 시 TossPaymentsError 발생
 */
async function callTossAPI<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const encodedKey = getEncodedSecretKey();
  const url = `${TOSS_API_BASE_URL}${endpoint}`;

  const response = await fetch(url, {
    ...options,
    headers: {
      'Authorization': `Basic ${encodedKey}`,
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

  const data = await response.json();

  if (!response.ok) {
    throw new TossPaymentsError(
      data.message || '토스페이먼츠 API 호출 실패',
      data.code || 'UNKNOWN_ERROR',
      response.status
    );
  }

  return data;
}

/**
 * 빌링키 발급 요청 파라미터
 */
export interface IssueBillingKeyRequest {
  /** 인증키 (카드 등록 성공 후 받은 authKey) */
  authKey: string;
  /** 고객 고유 키 (UUID 권장) */
  customerKey: string;
}

/**
 * 빌링키 발급 응답
 */
export interface IssueBillingKeyResponse {
  /** 빌링키 */
  billingKey: string;
  /** 카드 정보 */
  card?: {
    /** 카드 번호 (마스킹) */
    number: string;
    /** 카드 타입 (체크/신용) */
    cardType: string;
    /** 카드사 코드 */
    issuerCode: string;
    /** 카드사 이름 */
    issuerName: string;
    /** 카드 소유자 타입 (개인/법인) */
    ownerType: string;
  };
  /** 고객 키 */
  customerKey: string;
  /** 인증 날짜 */
  authenticatedAt: string;
}

/**
 * 빌링키를 발급합니다.
 *
 * authKey는 카드 등록 성공 후 successUrl의 쿼리 파라미터로 전달됩니다.
 *
 * @param request - 빌링키 발급 요청 파라미터
 * @returns 빌링키 및 카드 정보
 * @throws API 호출 실패 시 TossPaymentsError 발생
 *
 * @example
 * ```typescript
 * const response = await issueBillingKey({
 *   authKey: 'auth-key-from-success-url',
 *   customerKey: 'customer-uuid',
 * });
 *
 * console.log(response.billingKey); // 빌링키
 * console.log(response.card?.number); // 카드 번호 (마스킹)
 * ```
 */
export async function issueBillingKey(
  request: IssueBillingKeyRequest
): Promise<IssueBillingKeyResponse> {
  return callTossAPI<IssueBillingKeyResponse>(
    '/billing/authorizations/issue',
    {
      method: 'POST',
      body: JSON.stringify(request),
    }
  );
}

/**
 * 자동결제 승인 요청 파라미터
 */
export interface ChargeBillingRequest {
  /** 빌링키 */
  billingKey: string;
  /** 고객 키 */
  customerKey: string;
  /** 결제 금액 */
  amount: number;
  /** 주문 ID (고유값) */
  orderId: string;
  /** 주문명 */
  orderName: string;
  /** 고객 이메일 */
  customerEmail?: string;
  /** 고객 이름 */
  customerName?: string;
  /** 면세 금액 */
  taxFreeAmount?: number;
}

/**
 * 자동결제 승인 응답
 */
export interface ChargeBillingResponse {
  /** 결제 키 */
  paymentKey: string;
  /** 주문 ID */
  orderId: string;
  /** 결제 금액 */
  totalAmount: number;
  /** 상태 */
  status: string;
  /** 승인 날짜 */
  approvedAt: string;
}

/**
 * 빌링키로 자동결제를 승인합니다.
 *
 * @param request - 자동결제 승인 요청 파라미터
 * @returns 결제 결과
 * @throws API 호출 실패 시 TossPaymentsError 발생
 *
 * @example
 * ```typescript
 * const response = await chargeBilling({
 *   billingKey: 'billing-key',
 *   customerKey: 'customer-uuid',
 *   amount: 9900,
 *   orderId: `ORDER_${Date.now()}`,
 *   orderName: 'Pro 구독',
 *   customerEmail: 'user@example.com',
 * });
 *
 * console.log(response.paymentKey); // 결제 키
 * ```
 */
export async function chargeBilling(
  request: ChargeBillingRequest
): Promise<ChargeBillingResponse> {
  const { billingKey, ...body } = request;

  return callTossAPI<ChargeBillingResponse>(
    `/billing/${billingKey}`,
    {
      method: 'POST',
      body: JSON.stringify(body),
    }
  );
}

/**
 * 빌링키 삭제 요청 파라미터
 */
export interface DeleteBillingKeyRequest {
  /** 빌링키 */
  billingKey: string;
  /** 고객 키 */
  customerKey: string;
}

/**
 * 빌링키를 삭제합니다.
 *
 * 구독 해지 시 빌링키를 삭제하여 더 이상 자동결제가 발생하지 않도록 합니다.
 *
 * @param request - 빌링키 삭제 요청 파라미터
 * @throws API 호출 실패 시 TossPaymentsError 발생
 *
 * @example
 * ```typescript
 * await deleteBillingKey({
 *   billingKey: 'billing-key',
 *   customerKey: 'customer-uuid',
 * });
 * ```
 */
export async function deleteBillingKey(
  request: DeleteBillingKeyRequest
): Promise<void> {
  const { billingKey, customerKey } = request;

  await callTossAPI<void>(
    `/billing/authorizations/${billingKey}`,
    {
      method: 'DELETE',
      body: JSON.stringify({ customerKey }),
    }
  );
}

/**
 * 결제 취소 요청 파라미터
 */
export interface CancelPaymentRequest {
  /** 결제 키 */
  paymentKey: string;
  /** 취소 사유 */
  cancelReason: string;
  /** 취소 금액 (부분 취소 시 지정) */
  cancelAmount?: number;
}

/**
 * 결제를 취소(환불)합니다.
 *
 * @param request - 결제 취소 요청 파라미터
 * @returns 취소된 결제 정보
 * @throws API 호출 실패 시 TossPaymentsError 발생
 *
 * @example
 * ```typescript
 * // 전액 취소
 * await cancelPayment({
 *   paymentKey: 'payment-key',
 *   cancelReason: '고객 요청',
 * });
 *
 * // 부분 취소
 * await cancelPayment({
 *   paymentKey: 'payment-key',
 *   cancelReason: '부분 환불',
 *   cancelAmount: 5000,
 * });
 * ```
 */
export async function cancelPayment(
  request: CancelPaymentRequest
): Promise<any> {
  const { paymentKey, ...body } = request;

  return callTossAPI<any>(
    `/payments/${paymentKey}/cancel`,
    {
      method: 'POST',
      body: JSON.stringify(body),
    }
  );
}
</file>

<file path="src/lib/toss-payments/index.ts">
/**
 * 토스페이먼츠 SDK 클라이언트 (Client Component용)
 *
 * 자동결제(빌링) 연동을 위한 클라이언트 사이드 SDK 래퍼
 * 빌링키 발급을 위한 카드 등록 UI를 제공합니다.
 *
 * @see https://docs.tosspayments.com/sdk/v2/js
 */

'use client';

import { loadTossPayments } from '@tosspayments/tosspayments-sdk';
import { env } from '@/constants/env';

let tossPaymentsPromise: Promise<any> | null = null;

/**
 * 토스페이먼츠 SDK 인스턴스를 가져옵니다.
 *
 * 싱글톤 패턴으로 구현되어 있어 여러 번 호출해도 한 번만 초기화됩니다.
 *
 * @returns 토스페이먼츠 SDK 인스턴스
 * @throws 클라이언트 키가 설정되지 않은 경우 에러 발생
 */
export async function getTossPayments() {
  if (!env.NEXT_PUBLIC_TOSS_CLIENT_KEY) {
    throw new Error('NEXT_PUBLIC_TOSS_CLIENT_KEY가 설정되지 않았습니다.');
  }

  if (!tossPaymentsPromise) {
    tossPaymentsPromise = loadTossPayments(env.NEXT_PUBLIC_TOSS_CLIENT_KEY);
  }

  return tossPaymentsPromise;
}

/**
 * 결제 인스턴스를 생성합니다.
 *
 * @param customerKey - 고객 고유 키 (UUID 권장)
 * @returns 결제 인스턴스
 */
export async function createPayment(customerKey: string) {
  const tossPayments = await getTossPayments();
  return tossPayments.payment({ customerKey });
}

/**
 * 빌링 인증 요청 파라미터
 */
export interface BillingAuthRequest {
  /** 결제 수단 (카드만 지원) */
  method: 'CARD';
  /** 성공 시 리다이렉트 URL */
  successUrl: string;
  /** 실패 시 리다이렉트 URL */
  failUrl: string;
  /** 고객 이메일 */
  customerEmail?: string;
  /** 고객 이름 */
  customerName?: string;
}

/**
 * 카드 등록을 위한 빌링 인증을 요청합니다.
 *
 * @param customerKey - 고객 고유 키 (UUID 권장)
 * @param request - 빌링 인증 요청 파라미터
 * @throws 사용자가 취소하거나 에러 발생 시 예외 발생
 *
 * @example
 * ```typescript
 * try {
 *   await requestBillingAuth('customer-uuid', {
 *     method: 'CARD',
 *     successUrl: `${window.location.origin}/subscription/success`,
 *     failUrl: `${window.location.origin}/subscription/fail`,
 *     customerEmail: 'user@example.com',
 *     customerName: '홍길동',
 *   });
 * } catch (error) {
 *   if (error.code === 'USER_CANCEL') {
 *     console.log('사용자가 취소했습니다.');
 *   }
 * }
 * ```
 */
export async function requestBillingAuth(
  customerKey: string,
  request: BillingAuthRequest
) {
  const payment = await createPayment(customerKey);
  return payment.requestBillingAuth(request);
}
</file>

<file path="src/lib/utils/clipboard.ts">
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // 폴백: textarea 사용
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      const success = document.execCommand('copy');
      document.body.removeChild(textarea);
      return success;
    }
  } catch (error) {
    console.error('클립보드 복사 실패:', error);
    return false;
  }
}
</file>

<file path="src/lib/utils/date.ts">
import { format, parseISO } from 'date-fns';
import { ko } from 'date-fns/locale';

export function formatDate(date: string | Date, pattern = 'yyyy년 MM월 dd일'): string {
  const dateObj = typeof date === 'string' ? parseISO(date) : date;
  return format(dateObj, pattern, { locale: ko });
}

export function formatDateTime(date: string | Date): string {
  const dateObj = typeof date === 'string' ? parseISO(date) : date;
  return format(dateObj, 'yyyy년 MM월 dd일 HH:mm', { locale: ko });
}

export function formatBirthDate(date: string): string {
  return formatDate(date, 'yyyy-MM-dd');
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/utils/validation.ts">
/** 이메일 정규식 패턴 */
const EMAIL_PATTERN = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

/**
 * 이메일 형식이 유효한지 검증합니다.
 *
 * @param email - 검증할 이메일 주소
 * @returns 유효한 이메일이면 true, 그렇지 않으면 false
 *
 * @example
 * isValidEmail('test@example.com'); // true
 * isValidEmail('invalid-email'); // false
 */
export function isValidEmail(email: string): boolean {
  if (!email || typeof email !== 'string') {
    return false;
  }
  return EMAIL_PATTERN.test(email.trim());
}

/**
 * 숫자가 양수(0보다 큼)인지 검증합니다.
 *
 * @param num - 검증할 숫자
 * @returns 양수이면 true, 그렇지 않으면 false (0 또는 음수는 false)
 *
 * @example
 * isPositiveNumber(10); // true
 * isPositiveNumber(0); // false
 * isPositiveNumber(-5); // false
 */
export function isPositiveNumber(num: number): boolean {
  return typeof num === 'number' && num > 0;
}
</file>

<file path="src/middleware.ts">
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';

const isPublicRoute = createRouteMatcher([
  '/',
  '/sign-in(.*)',
  '/sign-up(.*)',
  '/api/webhooks/clerk',
]);

export default clerkMiddleware(async (auth, request) => {
  if (!isPublicRoute(request)) {
    await auth.protect();
  }
});

export const config = {
  matcher: [
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    '/(api|trpc)(.*)',
  ],
};
</file>

<file path=".mcp.json">
{
  "mcpServers": {
    "playwright": {
      "command": "npx",
      "args": [
        "@playwright/mcp@latest"
      ],
      "type": "stdio"
    },
    "shadcn": {
      "command": "npx",
      "args": [
        "shadcn@latest",
        "mcp"
      ],
      "type": "stdio"
    },
    "tosspayments-integration-guide": {
      "command": "npx",
      "args": [
        "-y",
        "@tosspayments/integration-guide-mcp@latest"
      ],
      "type": "stdio"
    }
  }
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="next.config.ts">
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  /* config options here */
  eslint: {
    ignoreDuringBuilds: true,
  },
  images: {
    remotePatterns: [
      {
        hostname: '**',
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test';
import dotenv from 'dotenv';
import * as path from 'path';

dotenv.config({ path: path.resolve(__dirname, '.env.test') });

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: process.env.SUPABASE_URL,
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'supabase-e2e',
      testMatch: /.*\.test\.ts$/,
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  globalSetup: require.resolve('./tests/e2e/global-setup'),
  globalTeardown: require.resolve('./tests/e2e/global-teardown'),
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "strictNullChecks": false,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noImplicitAny": false,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/(protected)/dashboard/new/page.tsx">
import { NewAnalysisForm } from '@/features/saju/components/new-analysis-form';
import { getSubscription } from '@/features/subscription/queries/get-subscription';

export default async function NewAnalysisPage() {
  const subscription = await getSubscription();

  return (
    <div className="container max-w-2xl mx-auto py-8">
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">새 사주분석</h1>
          <p className="text-muted-foreground mt-2">
            분석하실 분의 정보를 입력해주세요
          </p>
        </div>
        <NewAnalysisForm subscriptionInfo={subscription} />
      </div>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

@plugin "@tailwindcss/typography";
@plugin "tailwindcss-animate";

@custom-variant dark (&:where(.dark, .dark *));

@utility container {
  margin-inline: auto;
  width: 100%;
  padding-inline: 2rem;
  @media (width >= 1400px) {
    max-width: 1400px;
  }
}

@theme {
  --color-border: hsl(var(--border));
  --color-input: hsl(var(--input));
  --color-ring: hsl(var(--ring));
  --color-background: hsl(var(--background));
  --color-foreground: hsl(var(--foreground));

  --color-primary: hsl(var(--primary));
  --color-primary-foreground: hsl(var(--primary-foreground));

  --color-secondary: hsl(var(--secondary));
  --color-secondary-foreground: hsl(var(--secondary-foreground));

  --color-destructive: hsl(var(--destructive));
  --color-destructive-foreground: hsl(var(--destructive-foreground));

  --color-muted: hsl(var(--muted));
  --color-muted-foreground: hsl(var(--muted-foreground));

  --color-accent: hsl(var(--accent));
  --color-accent-foreground: hsl(var(--accent-foreground));

  --color-popover: hsl(var(--popover));
  --color-popover-foreground: hsl(var(--popover-foreground));

  --color-card: hsl(var(--card));
  --color-card-foreground: hsl(var(--card-foreground));

  --radius-lg: var(--radius);
  --radius-md: calc(var(--radius) - 2px);
  --radius-sm: calc(var(--radius) - 4px);

  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }
  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
}

/*
  The default border color has changed to `currentcolor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentcolor);
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
  html {
    scroll-behavior: smooth;
  }
}
</file>

<file path="src/app/providers.tsx">
// In Next.js, this file would be called: app/providers.tsx
"use client";

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { ThemeProvider } from "next-themes";
import { ClerkProvider } from "@clerk/nextjs";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient();

  return (
    <ClerkProvider>
      <ThemeProvider
        attribute="class"
        defaultTheme="system"
        enableSystem
        forcedTheme="light"
        disableTransitionOnChange
      >
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      </ThemeProvider>
    </ClerkProvider>
  );
}
</file>

<file path="src/components/home/faq-section.tsx">
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';

const faqs = [
  {
    question: '어떻게 사용하나요?',
    answer:
      'Google 계정으로 로그인 후 생년월일과 출생시간을 입력하면 AI가 자동으로 사주를 분석해드립니다.',
  },
  {
    question: '무료 체험 후 비용이 발생하나요?',
    answer:
      '초기 3회는 무료로 이용하실 수 있습니다. 이후 월 9,900원의 Pro 구독을 통해 월 10회 고급 분석을 이용하실 수 있습니다.',
  },
  {
    question: 'Pro 구독과 무료 버전의 차이는 무엇인가요?',
    answer:
      'Pro 구독은 더 정교한 AI 모델(gemini-2.5-pro)을 사용하며, 직업운, 사업운, 월별 운세 등 추가 분석을 제공합니다. 또한 월 10회까지 분석이 가능합니다.',
  },
  {
    question: '개인정보는 안전한가요?',
    answer:
      '네, 모든 데이터는 암호화되어 안전하게 저장되며, Google 인증을 통해 보안이 강화되어 있습니다. 사주분석 결과는 본인만 확인할 수 있습니다.',
  },
  {
    question: '출생시간을 모르는 경우에도 가능한가요?',
    answer:
      '네, 출생시간을 모르시는 경우 "출생시간 모름"을 선택하시면 됩니다. 다만 더 정확한 분석을 위해서는 출생시간 입력을 권장합니다.',
  },
  {
    question: '구독은 언제든지 취소할 수 있나요?',
    answer:
      '네, Pro 구독은 언제든지 취소 가능하며, 다음 결제일까지 Pro 혜택이 유지됩니다.',
  },
];

export function FAQSection() {
  return (
    <section id="faq" className="bg-white px-6 py-20">
      <div className="mx-auto max-w-3xl">
        <h2 className="mb-12 text-center text-4xl font-bold text-gray-900">
          자주 묻는 질문
        </h2>
        <Accordion type="single" collapsible className="w-full">
          {faqs.map((faq, index) => (
            <AccordionItem key={index} value={`item-${index}`}>
              <AccordionTrigger className="text-left text-lg font-medium">
                {faq.question}
              </AccordionTrigger>
              <AccordionContent className="text-gray-600">
                {faq.answer}
              </AccordionContent>
            </AccordionItem>
          ))}
        </Accordion>
      </div>
    </section>
  );
}
</file>

<file path="src/components/home/features-section.tsx">
import { Sparkles, UserCircle, History, Zap } from 'lucide-react';
import { FeatureCard } from './feature-card';

const features = [
  {
    icon: Sparkles,
    title: 'AI 기반 전문 분석',
    description:
      'Gemini API를 활용한 20년 경력 사주상담사 수준의 분석',
  },
  {
    icon: UserCircle,
    title: '간편한 Google 로그인',
    description: '클릭 한 번으로 시작, 복잡한 회원가입 절차 없음',
  },
  {
    icon: History,
    title: '분석 이력 관리',
    description: '과거 분석 결과를 언제든 다시 확인 가능',
  },
  {
    icon: Zap,
    title: '실시간 스트리밍',
    description: 'AI 분석 결과를 실시간으로 확인하며 기다림 없는 경험',
  },
];

export function FeaturesSection() {
  return (
    <section id="features" className="bg-white px-6 py-20">
      <div className="mx-auto max-w-7xl">
        <h2 className="mb-12 text-center text-4xl font-bold text-gray-900">
          주요 기능
        </h2>
        <div className="grid gap-8 sm:grid-cols-2 lg:grid-cols-4">
          {features.map((feature) => (
            <FeatureCard
              key={feature.title}
              icon={feature.icon}
              title={feature.title}
              description={feature.description}
            />
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/components/home/pricing-section.tsx">
import { PricingCard } from './pricing-card';

const pricingPlans = [
  {
    title: '무료',
    price: '₩0',
    description: '누구나 무료로 시작',
    features: [
      '초기 3회 분석 가능',
      '기본 AI 분석 (gemini-2.5-flash)',
      '분석 이력 저장',
      '마크다운 결과 복사',
    ],
    ctaText: '무료로 시작하기',
    ctaLink: '/dashboard',
    isPopular: false,
    isPro: false,
  },
  {
    title: 'Pro',
    price: '₩9,900',
    description: '고급 분석과 더 많은 혜택',
    features: [
      '월 10회 분석 가능',
      '고급 AI 분석 (gemini-2.5-pro)',
      '직업운, 사업운 분석',
      '월별 운세 및 길일 분석',
      '우선 지원',
    ],
    ctaText: 'Pro 시작하기',
    ctaLink: '/subscription',
    isPopular: true,
    isPro: true,
  },
];

export function PricingSection() {
  return (
    <section id="pricing" className="bg-gray-50 px-6 py-20">
      <div className="mx-auto max-w-6xl">
        <h2 className="mb-12 text-center text-4xl font-bold text-gray-900">
          요금 안내
        </h2>
        <div className="grid gap-8 md:grid-cols-2 max-w-4xl mx-auto">
          {pricingPlans.map((plan) => (
            <PricingCard
              key={plan.title}
              title={plan.title}
              price={plan.price}
              description={plan.description}
              features={plan.features}
              ctaText={plan.ctaText}
              ctaLink={plan.ctaLink}
              isPopular={plan.isPopular}
              isPro={plan.isPro}
            />
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/constants/server-env.ts">
import { z } from 'zod';
import 'server-only';

const serverEnvSchema = z.object({
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1).optional(),
  GEMINI_API_KEY: z.string().min(1).optional(),
  CLERK_SECRET_KEY: z.string().min(1).optional(),
  CLERK_WEBHOOK_SECRET: z.string().min(1).optional(), // 배포 후에만 필요
  TOSS_SECRET_KEY: z.string().min(1).optional(),
  CRON_SECRET: z.string().min(1).optional(),
});

const _serverEnv = serverEnvSchema.safeParse({
  SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
  GEMINI_API_KEY: process.env.GEMINI_API_KEY,
  CLERK_SECRET_KEY: process.env.CLERK_SECRET_KEY,
  CLERK_WEBHOOK_SECRET: process.env.CLERK_WEBHOOK_SECRET,
  TOSS_SECRET_KEY: process.env.TOSS_SECRET_KEY,
  CRON_SECRET: process.env.CRON_SECRET,
});

export type ServerEnv = z.infer<typeof serverEnvSchema>;

if (!_serverEnv.success) {
  console.warn('서버 환경 변수 검증 실패:', _serverEnv.error.flatten().fieldErrors);
  console.warn('일부 기능이 제한될 수 있습니다.');
}

export const serverEnv: ServerEnv = _serverEnv.success ? _serverEnv.data : {};
</file>

<file path="src/features/auth/context/current-user-context.tsx">
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useState,
  type ReactNode,
} from "react";
import { useQueryClient } from "@tanstack/react-query";
import { match, P } from "ts-pattern";
import { createClient } from "@/lib/supabase/browser-client";
import type {
  CurrentUserContextValue,
  CurrentUserSnapshot,
} from "../types";

const CurrentUserContext = createContext<CurrentUserContextValue | null>(null);

type CurrentUserProviderProps = {
  children: ReactNode;
  initialState: CurrentUserSnapshot;
};

export const CurrentUserProvider = ({
  children,
  initialState,
}: CurrentUserProviderProps) => {
  const queryClient = useQueryClient();
  const [snapshot, setSnapshot] = useState<CurrentUserSnapshot>(initialState);

  const refresh = useCallback(async () => {
    setSnapshot((prev) => ({ status: "loading", user: prev.user }));
    const supabase = createClient();

    try {
      const result = await supabase.auth.getUser();

      const nextSnapshot = match(result)
        .with({ data: { user: P.nonNullable } }, ({ data }) => ({
          status: "authenticated" as const,
          user: {
            id: data.user.id,
            email: data.user.email,
            appMetadata: data.user.app_metadata ?? {},
            userMetadata: data.user.user_metadata ?? {},
          },
        }))
        .otherwise(() => ({ status: "unauthenticated" as const, user: null }));

      setSnapshot(nextSnapshot);
      queryClient.setQueryData(["currentUser"], nextSnapshot);
    } catch (error) {
      const fallbackSnapshot: CurrentUserSnapshot = {
        status: "unauthenticated",
        user: null,
      };
      setSnapshot(fallbackSnapshot);
      queryClient.setQueryData(["currentUser"], fallbackSnapshot);
    }
  }, [queryClient]);

  const value = useMemo<CurrentUserContextValue>(() => {
    return {
      ...snapshot,
      refresh,
      isAuthenticated: snapshot.status === "authenticated",
      isLoading: snapshot.status === "loading",
    };
  }, [refresh, snapshot]);

  return (
    <CurrentUserContext.Provider value={value}>
      {children}
    </CurrentUserContext.Provider>
  );
};

export const useCurrentUserContext = () => {
  const value = useContext(CurrentUserContext);

  if (!value) {
    throw new Error("CurrentUserProvider가 트리 상단에 필요합니다.");
  }

  return value;
};
</file>

<file path="src/features/auth/server/load-current-user.ts">
import "server-only";

import type { User } from "@supabase/supabase-js";
import { createClient } from "@/lib/supabase/server-client";
import type { CurrentUserSnapshot } from "../types";

const mapUser = (user: User) => ({
  id: user.id,
  email: user.email,
  appMetadata: user.app_metadata ?? {},
  userMetadata: user.user_metadata ?? {},
});

export const loadCurrentUser = async (): Promise<CurrentUserSnapshot> => {
  const supabase = await createClient();
  const result = await supabase.auth.getUser();
  const user = result.data.user;

  if (user) {
    return {
      status: "authenticated",
      user: mapUser(user),
    };
  }

  return { status: "unauthenticated", user: null };
};
</file>

<file path="src/features/saju/actions/load-more-tests.ts">
'use server';

import { createClient } from '@/lib/supabase/server-client';
import { auth } from '@clerk/nextjs/server';
import type { SajuTestListItem } from '@/features/saju/types/result';

type LoadMoreTestsResult = {
  success: boolean;
  data?: SajuTestListItem[];
  error?: string;
  hasMore?: boolean;
};

export async function loadMoreTests(offset: number, limit = 10): Promise<LoadMoreTestsResult> {
  try {
    const { userId } = await auth();
    if (!userId) {
      return { success: false, error: 'Unauthorized' };
    }

    const supabase = await createClient();
    const { data, error } = await supabase
      .from('saju_tests')
      .select('id, name, birth_date, gender, result, created_at')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) {
      console.error('더보기 조회 실패:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code
      });
      return { success: false, error: error.message };
    }

    const tests: SajuTestListItem[] = data.map((test) => ({
      id: test.id,
      name: test.name,
      birthDate: test.birth_date,
      gender: test.gender as 'male' | 'female',
      createdAt: test.created_at,
      preview: test.result.slice(0, 100) + '...',
    }));

    return {
      success: true,
      data: tests,
      hasMore: data.length === limit,
    };
  } catch (error) {
    console.error('더보기 실행 실패:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다.',
    };
  }
}
</file>

<file path="src/features/saju/components/analysis-info-card.tsx">
'use client';

import { SajuTestResult } from '@/features/saju/types/result';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { formatDate, formatDateTime } from '@/lib/utils/date';
import { Sparkles } from 'lucide-react';

type AnalysisInfoCardProps = {
  sajuTest: SajuTestResult;
};

export function AnalysisInfoCard({ sajuTest }: AnalysisInfoCardProps) {
  const formatBirthTime = (time: string | null) => {
    if (!time) return '미상';
    const [hour, minute] = time.split(':');
    return `${hour}시 ${minute}분`;
  };

  const genderLabel = sajuTest.gender === 'male' ? '남성' : '여성';
  const genderVariant = sajuTest.gender === 'male' ? 'default' : 'secondary';

  return (
    <Card>
      <CardHeader>
        <CardTitle>분석 대상 정보</CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground min-w-[80px]">이름</span>
          <span className="font-semibold">{sajuTest.name}</span>
        </div>

        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground min-w-[80px]">생년월일</span>
          <span>{formatDate(sajuTest.birthDate)}</span>
        </div>

        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground min-w-[80px]">출생시간</span>
          <span>{formatBirthTime(sajuTest.birthTime)}</span>
        </div>

        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground min-w-[80px]">성별</span>
          <Badge variant={genderVariant}>{genderLabel}</Badge>
        </div>

        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground min-w-[80px]">분석 날짜</span>
          <span className="text-sm">{formatDateTime(sajuTest.createdAt)}</span>
        </div>

        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground min-w-[80px]">분석 유형</span>
          <Badge
            variant={sajuTest.modelUsed === 'pro' ? 'default' : 'secondary'}
            className="gap-1"
          >
            {sajuTest.modelUsed === 'pro' && <Sparkles className="h-3 w-3" />}
            {sajuTest.modelUsed === 'pro' ? 'Pro 고급 분석' : '기본 분석'}
          </Badge>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/saju/types/result.ts">
export type SajuTestResult = {
  id: string;
  userId: string;
  name: string;
  birthDate: string;
  birthTime: string | null;
  gender: 'male' | 'female';
  result: string; // 마크다운 텍스트
  modelUsed: 'flash' | 'pro'; // 사용된 모델
  createdAt: string;
};

export type SajuTestListItem = Pick<
  SajuTestResult,
  'id' | 'name' | 'birthDate' | 'gender' | 'createdAt'
> & {
  preview: string; // result의 첫 100자
};
</file>

<file path="src/features/subscription/queries/get-subscription.ts">
/**
 * 구독 정보 조회 함수
 *
 * 현재 사용자의 구독 상태 및 관련 정보를 조회합니다.
 * 구독 관리 페이지 및 대시보드 사이드바에서 사용됩니다.
 */

import { createClient } from '@/lib/supabase/server-client';
import { auth } from '@clerk/nextjs/server';
import 'server-only';

/**
 * 구독 정보 타입
 */
export type SubscriptionInfo = {
  /** 사용자 이메일 */
  userEmail: string;
  /** 구독 상태 */
  status: 'free' | 'pro' | 'cancelled' | 'payment_failed';
  /** 잔여 검사 횟수 */
  testCount: number;
  /** 다음 결제일 (ISO 8601 형식) */
  nextBillingDate: string | null;
  /** 카드 번호 마지막 4자리 */
  cardNumber: string | null;
  /** 카드사 */
  cardCompany: string | null;
};

/**
 * 현재 사용자의 구독 정보를 조회합니다.
 *
 * @returns 구독 정보 객체 또는 null (인증되지 않은 경우)
 *
 * @example
 * ```typescript
 * const subscription = await getSubscription();
 *
 * if (subscription) {
 *   console.log(subscription.status); // 'pro'
 *   console.log(subscription.testCount); // 10
 *   console.log(subscription.nextBillingDate); // '2025-02-01T00:00:00.000Z'
 * }
 * ```
 */
export async function getSubscription(): Promise<SubscriptionInfo | null> {
  const { userId } = await auth();
  if (!userId) return null;

  const supabase = await createClient();

  // 1. users 테이블에서 기본 정보 조회
  const { data: user, error: userError } = await supabase
    .from('users')
    .select('email, subscription_status, test_count')
    .eq('id', userId)
    .single();

  if (userError) {
    console.error('사용자 정보 조회 실패:', {
      message: userError.message,
      details: userError.details,
      hint: userError.hint,
      code: userError.code
    });
    return null;
  }

  if (!user) {
    console.error('사용자 정보 조회 실패: 사용자를 찾을 수 없습니다.');
    return null;
  }

  // 2. Pro 또는 취소 예약 상태인 경우 구독 정보 조회
  if (user.subscription_status === 'pro' || user.subscription_status === 'cancelled') {
    const { data: subscription, error: subError } = await supabase
      .from('subscriptions')
      .select('next_billing_date, card_number, card_company, status')
      .eq('user_id', userId)
      .single();

    if (subError) {
      console.error('구독 정보 조회 실패:', {
        message: subError.message,
        details: subError.details,
        hint: subError.hint,
        code: subError.code
      });
    }

    return {
      userEmail: user.email,
      status: user.subscription_status,
      testCount: user.test_count,
      nextBillingDate: subscription?.next_billing_date || null,
      cardNumber: subscription?.card_number || null,
      cardCompany: subscription?.card_company || null,
    };
  }

  // 3. 무료 사용자 또는 결제 실패
  return {
    userEmail: user.email,
    status: user.subscription_status,
    testCount: user.test_count,
    nextBillingDate: null,
    cardNumber: null,
    cardCompany: null,
  };
}

/**
 * 잔여 검사 횟수를 확인합니다.
 *
 * @returns 잔여 검사 횟수
 *
 * @example
 * ```typescript
 * const count = await getRemainingTestCount();
 * if (count <= 0) {
 *   console.log('검사 횟수가 부족합니다.');
 * }
 * ```
 */
export async function getRemainingTestCount(): Promise<number> {
  const { userId } = await auth();
  if (!userId) return 0;

  const supabase = await createClient();

  const { data: user, error } = await supabase
    .from('users')
    .select('test_count')
    .eq('id', userId)
    .single();

  if (error) {
    console.error('잔여 횟수 조회 실패:', {
      message: error.message,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    return 0;
  }

  if (!user) {
    console.error('잔여 횟수 조회 실패: 사용자를 찾을 수 없습니다.');
    return 0;
  }

  return user.test_count;
}

/**
 * 사용자가 Pro 구독자인지 확인합니다.
 *
 * @returns Pro 구독자 여부
 *
 * @example
 * ```typescript
 * const isPro = await isProSubscriber();
 * if (isPro) {
 *   console.log('Pro 전용 기능을 사용할 수 있습니다.');
 * }
 * ```
 */
export async function isProSubscriber(): Promise<boolean> {
  const { userId } = await auth();
  if (!userId) return false;

  const supabase = await createClient();

  const { data: user, error } = await supabase
    .from('users')
    .select('subscription_status')
    .eq('id', userId)
    .single();

  if (error) {
    console.error('구독 상태 조회 실패:', {
      message: error.message,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    return false;
  }

  if (!user) {
    console.error('구독 상태 조회 실패: 사용자를 찾을 수 없습니다.');
    return false;
  }

  // Pro 또는 취소 예약 상태는 Pro 혜택 유지
  return user.subscription_status === 'pro' || user.subscription_status === 'cancelled';
}
</file>

<file path="src/lib/gemini/prompts.ts">
/**
 * Gemini API 프롬프트 생성 함수
 *
 * 사주분석을 위한 프롬프트를 생성합니다.
 * 무료 사용자와 Pro 사용자에 대해 다른 프롬프트를 제공합니다.
 */

import type { SajuInput } from '@/features/saju/types/input';
import 'server-only';

/**
 * 기본 사주분석 프롬프트 (무료 사용자용)
 *
 * Gemini 2.0 Flash 모델과 함께 사용됩니다.
 * 기본적인 사주분석 항목을 포함합니다.
 *
 * @param input - 사주분석 입력 정보
 * @returns 프롬프트 문자열
 */
export function generateSajuPrompt(input: SajuInput): string {
  const birthTimeText = input.birthTime || '미상';
  const genderText = input.gender === 'male' ? '남성' : '여성';

  return `당신은 20년 경력의 전문 사주팔자 상담사입니다.

**입력 정보**:
- 성함: ${input.name}
- 생년월일: ${input.birthDate}
- 출생시간: ${birthTimeText}
- 성별: ${genderText}

**분석 요구사항**:
다음 섹션을 포함하여 상세한 사주분석 결과를 마크다운 형식으로 작성해주세요:

1. **천간(天干)과 지지(地支)**: 생년월일시의 사주팔자를 계산하고 해석
2. **오행(五行) 분석**: 목(木), 화(火), 토(土), 금(金), 수(水)의 균형 분석
3. **대운(大運)과 세운(歲運)**: 인생의 흐름과 현재 운세
4. **성격 분석**: 타고난 성격, 장단점, 대인관계 성향
5. **재운 분석**: 재물운, 재테크 성향
6. **건강운 분석**: 주의해야 할 건강 부위
7. **연애운 분석**: 이성관계, 결혼운

**출력 형식**: 마크다운 (제목, 목록, 강조 활용)

**금지 사항**:
- 의료·법률 조언 금지
- 확정적 미래 예측 금지
- 부정적·공격적 표현 금지

각 섹션은 명확한 제목(## 또는 ###)으로 구분하고, 이해하기 쉽게 작성해주세요.`;
}

/**
 * Pro 사주분석 프롬프트 (Pro 사용자용)
 *
 * Gemini 2.0 Flash 모델과 함께 사용됩니다.
 * Pro 전용 추가 분석 항목을 포함합니다.
 *
 * @param input - 사주분석 입력 정보
 * @returns 프롬프트 문자열
 */
export function generateProSajuPrompt(input: SajuInput): string {
  const birthTimeText = input.birthTime || '미상';
  const genderText = input.gender === 'male' ? '남성' : '여성';

  return `당신은 30년 경력의 전문 사주팔자 상담사입니다.

**입력 정보**:
- 성함: ${input.name}
- 생년월일: ${input.birthDate}
- 출생시간: ${birthTimeText}
- 성별: ${genderText}

**분석 요구사항** (Pro 고급 분석):
다음 섹션을 포함하여 상세한 사주분석 결과를 마크다운 형식으로 작성해주세요:

1. **천간(天干)과 지지(地支)**: 생년월일시의 사주팔자를 계산하고 해석
2. **오행(五行) 분석**: 목(木), 화(火), 토(土), 금(金), 수(水)의 균형 분석
3. **대운(大運)과 세운(歲運)**: 인생의 흐름과 현재 운세
4. **성격 분석**: 타고난 성격, 장단점, 대인관계 성향
5. **재운 분석**: 재물운, 재테크 성향
6. **건강운 분석**: 주의해야 할 건강 부위
7. **연애운 분석**: 이성관계, 결혼운
8. **직업운 및 사업운** (Pro 전용): 적합한 직업 분야, 사업 성공 가능성, 투자 조언
9. **월별 운세** (Pro 전용): 향후 12개월 운세 및 길일 분석

**출력 형식**: 마크다운 (제목, 목록, 강조 활용)

**금지 사항**:
- 의료·법률 조언 금지
- 확정적 미래 예측 금지
- 부정적·공격적 표현 금지

각 섹션은 명확한 제목(## 또는 ###)으로 구분하고, Pro 사용자에게 맞는 깊이 있는 분석을 제공해주세요.`;
}
</file>

<file path="src/lib/supabase/admin-client.ts">
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { serverEnv } from '@/constants/server-env';
import { env } from '@/constants/env';
import 'server-only';

export function createAdminClient() {
  return createClient<Database>(
    env.NEXT_PUBLIC_SUPABASE_URL!,
    serverEnv.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
      },
    }
  );
}
</file>

<file path="src/lib/supabase/browser-client.ts">
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from './types';
import { env } from '@/constants/env';

export function createClient() {
  return createBrowserClient<Database>(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );
}
</file>

<file path="src/lib/supabase/server-client.ts">
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from './types';
import { env } from '@/constants/env';

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient<Database>(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // Server Component에서는 쿠키 설정 불가, 무시
          }
        },
      },
    }
  );
}
</file>

<file path="src/app/(protected)/dashboard/page.tsx">
import type { Metadata } from 'next';
import Link from 'next/link';
import { getSajuTests } from '@/features/saju/queries/get-saju-tests';
import { DashboardContent } from '@/features/saju/components/dashboard-content';
import { Button } from '@/components/ui/button';

export const metadata: Metadata = {
  title: '내 사주분석 이력 | Vibe Fortune',
  description: '과거 사주분석 결과를 확인하고 새로운 분석을 시작하세요',
};

export default async function DashboardPage() {
  const tests = await getSajuTests();

  return (
    <div className="space-y-6">
      {/* 페이지 헤더 */}
      <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
        <div>
          <h1 className="text-3xl font-bold">내 사주분석 이력</h1>
          <p className="text-muted-foreground mt-1">
            과거 사주분석 결과를 확인하고 새로운 분석을 시작하세요
          </p>
        </div>
        <Link href="/dashboard/new">
          <Button>새 검사하기</Button>
        </Link>
      </div>

      {/* 메인 컨텐츠 (Client Component) */}
      <DashboardContent initialTests={tests} />
    </div>
  );
}
</file>

<file path="src/app/login/page.tsx">
"use client";

import { useCallback, useEffect, useState, Suspense } from "react";
import Image from "next/image";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { createClient } from "@/lib/supabase/browser-client";
import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";

type LoginPageProps = {
  params: Promise<Record<string, never>>;
};

function LoginForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { refresh, isAuthenticated } = useCurrentUser();
  const [formState, setFormState] = useState({ email: "", password: "" });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    if (isAuthenticated) {
      const redirectedFrom = searchParams.get("redirectedFrom") ?? "/";
      router.replace(redirectedFrom);
    }
  }, [isAuthenticated, router, searchParams]);

  const handleChange = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const { name, value } = event.target;
      setFormState((prev) => ({ ...prev, [name]: value }));
    },
    []
  );

  const handleSubmit = useCallback(
    async (event: React.FormEvent<HTMLFormElement>) => {
      event.preventDefault();
      setIsSubmitting(true);
      setErrorMessage(null);
      const supabase = createClient();

      try {
        const result = await supabase.auth.signInWithPassword({
          email: formState.email,
          password: formState.password,
        });

        const nextAction = result.error
          ? result.error.message ?? "로그인에 실패했습니다."
          : ("success" as const);

        if (nextAction === "success") {
          await refresh();
          const redirectedFrom = searchParams.get("redirectedFrom") ?? "/";
          router.replace(redirectedFrom);
        } else {
          setErrorMessage(nextAction);
        }
      } catch (error) {
        setErrorMessage("로그인 처리 중 오류가 발생했습니다.");
      } finally {
        setIsSubmitting(false);
      }
    },
    [formState.email, formState.password, refresh, router, searchParams]
  );

  if (isAuthenticated) {
    return null;
  }

  return (
    <div className="mx-auto flex min-h-screen w-full max-w-4xl flex-col items-center justify-center gap-10 px-6 py-16">
      <header className="flex flex-col items-center gap-3 text-center">
        <h1 className="text-3xl font-semibold">로그인</h1>
        <p className="text-slate-500">
          Supabase 계정으로 로그인하고 보호된 페이지에 접근하세요.
        </p>
      </header>
      <div className="grid w-full gap-8 md:grid-cols-2">
        <form
          onSubmit={handleSubmit}
          className="flex flex-col gap-4 rounded-xl border border-slate-200 p-6 shadow-sm"
        >
          <label className="flex flex-col gap-2 text-sm text-slate-700">
            이메일
            <input
              type="email"
              name="email"
              autoComplete="email"
              required
              value={formState.email}
              onChange={handleChange}
              className="rounded-md border border-slate-300 px-3 py-2 focus:border-slate-500 focus:outline-none"
            />
          </label>
          <label className="flex flex-col gap-2 text-sm text-slate-700">
            비밀번호
            <input
              type="password"
              name="password"
              autoComplete="current-password"
              required
              value={formState.password}
              onChange={handleChange}
              className="rounded-md border border-slate-300 px-3 py-2 focus:border-slate-500 focus:outline-none"
            />
          </label>
          {errorMessage ? (
            <p className="text-sm text-rose-500">{errorMessage}</p>
          ) : null}
          <button
            type="submit"
            disabled={isSubmitting}
            className="rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white transition hover:bg-slate-700 disabled:cursor-not-allowed disabled:bg-slate-400"
          >
            {isSubmitting ? "로그인 중" : "로그인"}
          </button>
          <p className="text-xs text-slate-500">
            계정이 없으신가요?{" "}
            <Link
              href="/signup"
              className="font-medium text-slate-700 underline hover:text-slate-900"
            >
              회원가입
            </Link>
          </p>
        </form>
        <figure className="overflow-hidden rounded-xl border border-slate-200">
          <Image
            src="https://picsum.photos/seed/login/640/640"
            alt="로그인"
            width={640}
            height={640}
            className="h-full w-full object-cover"
            priority
          />
        </figure>
      </div>
    </div>
  );
}

export default function LoginPage({ params }: LoginPageProps) {
  void params;
  
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <LoginForm />
    </Suspense>
  );
}
</file>

<file path="src/app/signup/page.tsx">
"use client";

import { useCallback, useEffect, useMemo, useState, Suspense } from "react";
import Image from "next/image";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { createClient } from "@/lib/supabase/browser-client";
import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";

const defaultFormState = {
  email: "",
  password: "",
  confirmPassword: "",
};

type SignupPageProps = {
  params: Promise<Record<string, never>>;
};

function SignupForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { isAuthenticated, refresh } = useCurrentUser();
  const [formState, setFormState] = useState(defaultFormState);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [infoMessage, setInfoMessage] = useState<string | null>(null);

  useEffect(() => {
    if (isAuthenticated) {
      const redirectedFrom = searchParams.get("redirectedFrom") ?? "/";
      router.replace(redirectedFrom);
    }
  }, [isAuthenticated, router, searchParams]);

  const isSubmitDisabled = useMemo(
    () =>
      !formState.email.trim() ||
      !formState.password.trim() ||
      formState.password !== formState.confirmPassword,
    [formState.confirmPassword, formState.email, formState.password]
  );

  const handleChange = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const { name, value } = event.target;
      setFormState((previous) => ({ ...previous, [name]: value }));
    },
    []
  );

  const handleSubmit = useCallback(
    async (event: React.FormEvent<HTMLFormElement>) => {
      event.preventDefault();
      setIsSubmitting(true);
      setErrorMessage(null);
      setInfoMessage(null);

      if (formState.password !== formState.confirmPassword) {
        setErrorMessage("비밀번호가 일치하지 않습니다.");
        setIsSubmitting(false);
        return;
      }

      const supabase = createClient();

      try {
        const result = await supabase.auth.signUp({
          email: formState.email,
          password: formState.password,
        });

        if (result.error) {
          setErrorMessage(result.error.message ?? "회원가입에 실패했습니다.");
          setIsSubmitting(false);
          return;
        }

        await refresh();

        const redirectedFrom = searchParams.get("redirectedFrom") ?? "/";

        if (result.data.session) {
          router.replace(redirectedFrom);
          return;
        }

        setInfoMessage(
          "확인 이메일을 보냈습니다. 이메일 인증 후 로그인해 주세요."
        );
        router.prefetch("/login");
        setFormState(defaultFormState);
      } catch (error) {
        setErrorMessage("회원가입 처리 중 문제가 발생했습니다.");
      } finally {
        setIsSubmitting(false);
      }
    },
    [formState.confirmPassword, formState.email, formState.password, refresh, router, searchParams]
  );

  if (isAuthenticated) {
    return null;
  }

  return (
    <div className="mx-auto flex min-h-screen w-full max-w-4xl flex-col items-center justify-center gap-10 px-6 py-16">
      <header className="flex flex-col items-center gap-3 text-center">
        <h1 className="text-3xl font-semibold">회원가입</h1>
        <p className="text-slate-500">
          Supabase 계정으로 회원가입하고 프로젝트를 시작하세요.
        </p>
      </header>
      <div className="grid w-full gap-8 md:grid-cols-2">
        <form
          onSubmit={handleSubmit}
          className="flex flex-col gap-4 rounded-xl border border-slate-200 p-6 shadow-sm"
        >
          <label className="flex flex-col gap-2 text-sm text-slate-700">
            이메일
            <input
              type="email"
              name="email"
              autoComplete="email"
              required
              value={formState.email}
              onChange={handleChange}
              className="rounded-md border border-slate-300 px-3 py-2 focus:border-slate-500 focus:outline-none"
            />
          </label>
          <label className="flex flex-col gap-2 text-sm text-slate-700">
            비밀번호
            <input
              type="password"
              name="password"
              autoComplete="new-password"
              required
              value={formState.password}
              onChange={handleChange}
              className="rounded-md border border-slate-300 px-3 py-2 focus:border-slate-500 focus:outline-none"
            />
          </label>
          <label className="flex flex-col gap-2 text-sm text-slate-700">
            비밀번호 확인
            <input
              type="password"
              name="confirmPassword"
              autoComplete="new-password"
              required
              value={formState.confirmPassword}
              onChange={handleChange}
              className="rounded-md border border-slate-300 px-3 py-2 focus:border-slate-500 focus:outline-none"
            />
          </label>
          {errorMessage ? (
            <p className="text-sm text-rose-500">{errorMessage}</p>
          ) : null}
          {infoMessage ? (
            <p className="text-sm text-emerald-600">{infoMessage}</p>
          ) : null}
          <button
            type="submit"
            disabled={isSubmitting || isSubmitDisabled}
            className="rounded-md bg-slate-900 px-4 py-2 text-sm font-medium text-white transition hover:bg-slate-700 disabled:cursor-not-allowed disabled:bg-slate-400"
          >
            {isSubmitting ? "등록 중" : "회원가입"}
          </button>
          <p className="text-xs text-slate-500">
            이미 계정이 있으신가요?{" "}
            <Link
              href="/login"
              className="font-medium text-slate-700 underline hover:text-slate-900"
            >
              로그인으로 이동
            </Link>
          </p>
        </form>
        <figure className="overflow-hidden rounded-xl border border-slate-200">
          <Image
            src="https://picsum.photos/seed/signup/640/640"
            alt="회원가입"
            width={640}
            height={640}
            className="h-full w-full object-cover"
            priority
          />
        </figure>
      </div>
    </div>
  );
}

export default function SignupPage({ params }: SignupPageProps) {
  void params;
  
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <SignupForm />
    </Suspense>
  );
}
</file>

<file path="src/components/home/hero-section.tsx">
'use client';

import Link from 'next/link';
import { SignInButton, SignedIn, SignedOut } from '@clerk/nextjs';
import { Button } from '@/components/ui/button';

export function HeroSection() {
  return (
    <section
      id="hero"
      className="relative flex min-h-[600px] items-center justify-center bg-gradient-to-br from-indigo-50 via-white to-purple-50 px-6 py-20 md:py-32"
    >
      <div className="mx-auto max-w-4xl text-center">
        <h1 className="mb-6 text-5xl font-bold tracking-tight text-gray-900 md:text-6xl lg:text-7xl">
          AI가 분석하는 나만의 사주팔자
        </h1>
        <p className="mb-8 text-xl text-gray-600 md:text-2xl">
          Google 계정으로 1분 안에 시작하세요
        </p>

        <div className="flex justify-center">
          <SignedOut>
            <SignInButton mode="modal">
              <Button size="lg" className="text-lg px-8 py-6">
                무료로 시작하기
              </Button>
            </SignInButton>
          </SignedOut>
          <SignedIn>
            <Link href="/dashboard">
              <Button size="lg" className="text-lg px-8 py-6">
                이용하기
              </Button>
            </Link>
          </SignedIn>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/components/layout/dashboard-header.tsx">
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { UserButton } from '@clerk/nextjs';
import { cn } from '@/lib/utils';

const navItems = [
  { label: '대시보드', href: '/dashboard' },
  { label: '새 검사', href: '/dashboard/new' },
  { label: '구독 관리', href: '/subscription' },
];

export function DashboardHeader() {
  const pathname = usePathname();

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-14 items-center">
        <Link href="/" className="mr-6 flex items-center space-x-2">
          <span className="font-bold text-xl">Vibe Fortune</span>
        </Link>
        <nav className="flex items-center gap-6 flex-1">
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              className={cn(
                'text-sm font-medium transition-colors hover:text-primary',
                pathname === item.href
                  ? 'text-foreground'
                  : 'text-muted-foreground'
              )}
            >
              {item.label}
            </Link>
          ))}
        </nav>
        <UserButton afterSignOutUrl="/" />
      </div>
    </header>
  );
}
</file>

<file path="src/components/layout/home-header.tsx">
'use client';

import Link from 'next/link';
import { SignInButton, SignedIn, SignedOut, UserButton } from '@clerk/nextjs';
import { Button } from '@/components/ui/button';

export function HomeHeader() {
  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-backdrop-filter:bg-background/60">
      <div className="container flex h-14 items-center">
        <Link href="/" className="mr-6 flex items-center space-x-2">
          <span className="font-bold text-xl">Vibe Fortune</span>
        </Link>
        <nav className="flex items-center gap-6 flex-1">
          <Link
            href="/#features"
            className="text-sm font-medium text-muted-foreground hover:text-primary"
          >
            서비스
          </Link>
          <Link
            href="/#pricing"
            className="text-sm font-medium text-muted-foreground hover:text-primary"
          >
            가격
          </Link>
          <Link
            href="/#faq"
            className="text-sm font-medium text-muted-foreground hover:text-primary"
          >
            FAQ
          </Link>
        </nav>
        <div className="flex items-center gap-4">
          <SignedOut>
            <SignInButton mode="modal">
              <Button>시작하기</Button>
            </SignInButton>
          </SignedOut>
          <SignedIn>
            <Link href="/dashboard">
              <Button variant="outline">이용하기</Button>
            </Link>
            <UserButton afterSignOutUrl="/" />
          </SignedIn>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="src/constants/env.ts">
import { z } from 'zod';

const clientEnvSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url().optional(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1).optional(),
  NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1).optional(),
  NEXT_PUBLIC_TOSS_CLIENT_KEY: z.string().min(1).optional(),
  NEXT_PUBLIC_BASE_URL: z.string().url().optional(),
});

const _clientEnv = clientEnvSchema.safeParse({
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,
  NEXT_PUBLIC_TOSS_CLIENT_KEY: process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY,
  NEXT_PUBLIC_BASE_URL: process.env.NEXT_PUBLIC_BASE_URL,
});

export type ClientEnv = z.infer<typeof clientEnvSchema>;

if (!_clientEnv.success) {
  console.warn('환경 변수 검증 실패:', _clientEnv.error.flatten().fieldErrors);
  console.warn('일부 기능이 제한될 수 있습니다.');
}

export const env: ClientEnv = _clientEnv.success ? _clientEnv.data : {};
</file>

<file path="src/features/saju/components/analysis-result-section.tsx">
'use client';

import { useState } from 'react';
import { MarkdownRenderer } from '@/components/markdown-renderer';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Copy, Check, Sparkles, Info } from 'lucide-react';
import { copyToClipboard } from '@/lib/utils/clipboard';
import { useToast } from '@/hooks/use-toast';
import { DeleteTestDialog } from './delete-test-dialog';

type AnalysisResultSectionProps = {
  result: string;
  modelUsed: 'flash' | 'pro';
  testId: string;
  testName: string;
};

export function AnalysisResultSection({ result, modelUsed, testId, testName }: AnalysisResultSectionProps) {
  const [copyIcon, setCopyIcon] = useState<'copy' | 'check'>('copy');
  const { toast } = useToast();

  const handleCopy = async () => {
    const success = await copyToClipboard(result);

    if (success) {
      toast({
        title: '복사 완료',
        description: '사주분석 결과가 클립보드에 복사되었습니다.',
      });

      setCopyIcon('check');
      setTimeout(() => {
        setCopyIcon('copy');
      }, 2000);
    } else {
      toast({
        title: '복사 실패',
        description: '복사에 실패했습니다. 다시 시도해주세요.',
        variant: 'destructive',
      });
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">사주분석 결과</h2>
        <div className="flex gap-2">
          <Button
            onClick={handleCopy}
            variant="outline"
            size="sm"
            className="gap-2"
            aria-label="사주분석 결과 복사"
          >
            {copyIcon === 'copy' ? (
              <Copy className="h-4 w-4" />
            ) : (
              <Check className="h-4 w-4" />
            )}
            결과 복사
          </Button>
          <DeleteTestDialog testId={testId} testName={testName} />
        </div>
      </div>

      {modelUsed === 'pro' ? (
        <Alert className="border-primary bg-primary/5">
          <Sparkles className="h-4 w-4 text-primary" />
          <AlertDescription>
            이 분석은 <strong>Pro 구독</strong>으로 생성된 고급 분석입니다.
            직업운, 사업운, 월별 운세가 포함되어 있습니다.
          </AlertDescription>
        </Alert>
      ) : (
        <Alert>
          <Info className="h-4 w-4" />
          <AlertDescription>
            기본 분석 결과입니다. <strong>Pro 구독</strong> 시 더욱 상세한 분석을 받을 수 있습니다.
          </AlertDescription>
        </Alert>
      )}

      <div className="border rounded-lg p-6">
        <MarkdownRenderer content={result} />
      </div>
    </div>
  );
}
</file>

<file path="src/features/saju/components/result-detail-client.tsx">
'use client';

import { SajuTestResult } from '@/features/saju/types/result';
import { DashboardHeader } from '@/components/layout/dashboard-header';
import { AnalysisInfoCard } from './analysis-info-card';
import { AnalysisResultSection } from './analysis-result-section';
import { NavigationButtons } from './navigation-buttons';

type ResultDetailClientProps = {
  sajuTest: SajuTestResult;
};

export function ResultDetailClient({ sajuTest }: ResultDetailClientProps) {
  return (
    <div className="min-h-screen flex flex-col">
      <DashboardHeader />

      <main className="container mx-auto py-8 px-4 flex-1">
        <div className="max-w-4xl mx-auto space-y-6">
          <AnalysisInfoCard sajuTest={sajuTest} />
          <AnalysisResultSection 
            result={sajuTest.result} 
            modelUsed={sajuTest.modelUsed}
            testId={sajuTest.id}
            testName={sajuTest.name}
          />
          <NavigationButtons />
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/(protected)/layout.tsx">
import { type ReactNode } from "react";
import { DashboardHeader } from "@/components/layout/dashboard-header";
import { DashboardSidebar } from "@/components/layout/dashboard-sidebar";
import { MobileSidebar } from "@/components/layout/mobile-sidebar";
import { getSubscription } from "@/features/subscription/queries/get-subscription";

type ProtectedLayoutProps = {
  children: ReactNode;
};

export default async function ProtectedLayout({ children }: ProtectedLayoutProps) {
  // 구독 정보 조회
  const subscription = await getSubscription();

  return (
    <div className="min-h-screen flex flex-col">
      <DashboardHeader />
      <div className="flex flex-1">
        {/* 데스크톱 사이드바 */}
        {subscription && (
          <DashboardSidebar
            userEmail={subscription.userEmail}
            subscriptionStatus={subscription.status}
            testCount={subscription.testCount}
            nextBillingDate={subscription.nextBillingDate}
          />
        )}

        {/* 메인 컨텐츠 */}
        <main className="flex-1 p-4 md:p-8">
          {children}
        </main>
      </div>

      {/* 모바일 사이드바 */}
      {subscription && (
        <MobileSidebar
          userEmail={subscription.userEmail}
          subscriptionStatus={subscription.status}
          testCount={subscription.testCount}
          nextBillingDate={subscription.nextBillingDate}
        />
      )}
    </div>
  );
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import "./globals.css";
import Providers from "./providers";

export const metadata: Metadata = {
  title: 'Vibe Fortune - AI 기반 사주분석 서비스',
  description:
    'Google 계정으로 1분 안에 시작하는 AI 사주팔자 분석. 무료 체험 후 Pro 구독으로 월 10회 고급 분석을 이용하세요.',
  keywords: ['사주분석', 'AI 사주', '사주팔자', 'Gemini AI', '무료 사주'],
  openGraph: {
    title: 'Vibe Fortune - AI 기반 사주분석 서비스',
    description: 'Google 계정으로 1분 안에 시작하는 AI 사주팔자 분석',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Vibe Fortune - AI 기반 사주분석 서비스',
    description: 'Google 계정으로 1분 안에 시작하는 AI 사주팔자 분석',
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ko" suppressHydrationWarning>
      <body className="antialiased font-sans">
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
'use client';

import { HomeHeader } from '@/components/layout/home-header';
import { HeroSection } from '@/components/home/hero-section';
import { FeaturesSection } from '@/components/home/features-section';
import { PricingSection } from '@/components/home/pricing-section';
import { FAQSection } from '@/components/home/faq-section';
import { Footer } from '@/components/home/footer';

export default function HomePage() {
  return (
    <div className="min-h-screen">
      <HomeHeader />
      <main>
        <HeroSection />
        <FeaturesSection />
        <PricingSection />
        <FAQSection />
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="src/features/saju/components/new-analysis-form.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { sajuInputSchema, type SajuInput } from '../types/input';
import { createSajuTest } from '../actions/create-saju-test';
import { useToast } from '@/hooks/use-toast';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { TimePicker } from '@/components/ui/time-picker';
import { Spinner } from '@/components/ui/spinner';
import { Card, CardContent } from '@/components/ui/card';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import type { SubscriptionInfo } from '@/features/subscription/queries/get-subscription';

interface NewAnalysisFormProps {
  subscriptionInfo: SubscriptionInfo | null;
}

export function NewAnalysisForm({ subscriptionInfo }: NewAnalysisFormProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [birthTimeUnknown, setBirthTimeUnknown] = useState(false);
  const [showSubscriptionDialog, setShowSubscriptionDialog] = useState(false);
  const { toast } = useToast();
  const router = useRouter();

  const {
    register,
    handleSubmit,
    setValue,
    watch,
    formState: { errors, isValid },
  } = useForm<SajuInput>({
    resolver: zodResolver(sajuInputSchema),
    mode: 'onChange',
    defaultValues: {
      name: '',
      birthDate: '',
      birthTime: null,
      birthTimeUnknown: false,
      gender: undefined,
    },
  });

  const watchGender = watch('gender');

  const onSubmit = async (data: SajuInput) => {
    setIsLoading(true);

    try {
      const result = await createSajuTest(data);

      if (!result.success && 'error' in result) {
        // 횟수 부족 에러 감지
        if (result.error.includes('검사 횟수가 부족합니다')) {
          setShowSubscriptionDialog(true);
        } else {
          toast({
            variant: 'destructive',
            title: '분석 실패',
            description: result.error,
          });
        }
        setIsLoading(false);
      }
      // 성공 시 서버 액션 내부에서 redirect 처리됨
    } catch (error) {
      toast({
        variant: 'destructive',
        title: '오류 발생',
        description: '분석 중 오류가 발생했습니다. 다시 시도해주세요.',
      });
      setIsLoading(false);
    }
  };

  const handleBirthTimeUnknownChange = (checked: boolean) => {
    setBirthTimeUnknown(checked);
    setValue('birthTimeUnknown', checked);
    if (checked) {
      setValue('birthTime', null);
    }
  };

  return (
    <>
      <Card>
        <CardContent className="pt-6">
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          {/* 성함 입력 */}
          <div className="space-y-2">
            <Label htmlFor="name">
              성함 <span className="text-destructive">*</span>
            </Label>
            <Input
              id="name"
              {...register('name')}
              placeholder="성함을 입력해주세요"
              disabled={isLoading}
              className={errors.name ? 'border-destructive' : ''}
            />
            {errors.name && (
              <p className="text-sm text-destructive">{errors.name.message}</p>
            )}
          </div>

          {/* 생년월일 입력 */}
          <div className="space-y-2">
            <Label htmlFor="birthDate">
              생년월일 <span className="text-destructive">*</span>
            </Label>
            <Input
              id="birthDate"
              {...register('birthDate')}
              placeholder="YYYY-MM-DD (예: 2000-01-01)"
              disabled={isLoading}
              className={errors.birthDate ? 'border-destructive' : ''}
            />
            {errors.birthDate && (
              <p className="text-sm text-destructive">
                {errors.birthDate.message}
              </p>
            )}
          </div>

          {/* 출생시간 입력 */}
          <div className="space-y-2">
            <Label htmlFor="birthTime">출생시간</Label>
            <div className="space-y-3">
              <TimePicker
                value={watch('birthTime') || undefined}
                onChange={(time) => {
                  setValue('birthTime', time, { shouldValidate: true });
                }}
                disabled={isLoading || birthTimeUnknown}
              />
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="birthTimeUnknown"
                  checked={birthTimeUnknown}
                  onCheckedChange={handleBirthTimeUnknownChange}
                  disabled={isLoading}
                />
                <label
                  htmlFor="birthTimeUnknown"
                  className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                >
                  출생시간 모름
                </label>
              </div>
            </div>
            {errors.birthTime && (
              <p className="text-sm text-destructive">
                {errors.birthTime.message}
              </p>
            )}
          </div>

          {/* 성별 선택 */}
          <div className="space-y-2">
            <Label>
              성별 <span className="text-destructive">*</span>
            </Label>
            <RadioGroup
              value={watchGender}
              onValueChange={(value) =>
                setValue('gender', value as 'male' | 'female', {
                  shouldValidate: true,
                })
              }
              disabled={isLoading}
              className="flex gap-4"
            >
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="male" id="male" />
                <Label htmlFor="male" className="font-normal">
                  남성
                </Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="female" id="female" />
                <Label htmlFor="female" className="font-normal">
                  여성
                </Label>
              </div>
            </RadioGroup>
            {errors.gender && (
              <p className="text-sm text-destructive">
                {errors.gender.message}
              </p>
            )}
          </div>

          {/* 제출 버튼 */}
          <Button
            type="submit"
            className="w-full"
            disabled={!isValid || isLoading}
          >
            {isLoading ? (
              <div className="flex items-center gap-2">
                <Spinner size="sm" />
                <span>분석 중입니다... (10-30초 소요)</span>
              </div>
            ) : (
              '검사 시작'
            )}
          </Button>
        </form>
      </CardContent>
    </Card>

      {/* 구독 유도 다이얼로그 */}
      <AlertDialog open={showSubscriptionDialog} onOpenChange={setShowSubscriptionDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>검사 횟수 부족</AlertDialogTitle>
            <AlertDialogDescription>
              {subscriptionInfo?.status === 'free' || subscriptionInfo?.status === 'payment_failed' ? (
                'Pro 구독을 통해 월 10회 고급 분석을 이용하세요.'
              ) : subscriptionInfo?.status === 'pro' || subscriptionInfo?.status === 'cancelled' ? (
                subscriptionInfo.nextBillingDate ?
                  `다음 결제일(${new Date(subscriptionInfo.nextBillingDate).toLocaleDateString('ko-KR')})에 검사 횟수가 충전됩니다.` :
                  '검사 횟수가 부족합니다. 구독 관리 페이지를 확인해주세요.'
              ) : (
                'Pro 구독을 통해 월 10회 고급 분석을 이용하세요.'
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            {subscriptionInfo?.status === 'free' || subscriptionInfo?.status === 'payment_failed' ? (
              <>
                <AlertDialogCancel>취소</AlertDialogCancel>
                <AlertDialogAction
                  onClick={() => {
                    router.push('/subscription');
                  }}
                >
                  구독하기
                </AlertDialogAction>
              </>
            ) : (
              <AlertDialogAction
                onClick={() => {
                  setShowSubscriptionDialog(false);
                }}
              >
                확인
              </AlertDialogAction>
            )}
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
</file>

<file path="src/features/saju/queries/get-saju-test.ts">
import { createClient } from '@/lib/supabase/server-client';
import { auth } from '@clerk/nextjs/server';
import type { SajuTestResult } from '@/features/saju/types/result';
import 'server-only';

export async function getSajuTest(
  id: string
): Promise<SajuTestResult | null> {
  const { userId } = await auth();
  
  if (!userId) {
    return null;
  }

  const supabase = await createClient();

  const { data, error } = await supabase
    .from('saju_tests')
    .select('*')
    .eq('id', id)
    .eq('user_id', userId)
    .single();

  if (error) {
    console.error('사주분석 조회 실패:', {
      message: error.message,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    return null;
  }

  if (!data) {
    console.error('사주분석 조회 실패: 데이터를 찾을 수 없습니다.');
    return null;
  }

  return {
    id: data.id,
    userId: data.user_id,
    name: data.name,
    birthDate: data.birth_date,
    birthTime: data.birth_time,
    gender: data.gender as 'male' | 'female',
    result: data.result,
    modelUsed: (data.model_used as 'flash' | 'pro') || 'flash',
    createdAt: data.created_at,
  };
}
</file>

<file path="src/features/saju/queries/get-saju-tests.ts">
import { createClient } from '@/lib/supabase/server-client';
import { auth } from '@clerk/nextjs/server';
import type { SajuTestListItem } from '@/features/saju/types/result';
import 'server-only';

export async function getSajuTests(limit = 10): Promise<SajuTestListItem[]> {
  const { userId } = await auth();
  
  if (!userId) {
    return [];
  }

  const supabase = await createClient();

  const { data, error } = await supabase
    .from('saju_tests')
    .select('id, name, birth_date, gender, result, created_at')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .limit(limit);

  if (error) {
    console.error('사주분석 목록 조회 실패:', {
      message: error.message,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    return [];
  }

  return data.map((test) => ({
    id: test.id,
    name: test.name,
    birthDate: test.birth_date,
    gender: test.gender as 'male' | 'female',
    createdAt: test.created_at,
    preview: test.result.slice(0, 100) + '...',
  }));
}
</file>

<file path="src/lib/supabase/types.ts">
export type Database = {
  public: {
    Tables: {
      users: {
        Row: {
          id: string;
          email: string;
          name: string;
          subscription_status: 'free' | 'pro' | 'cancelled' | 'payment_failed';
          test_count: number;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id: string;
          email: string;
          name: string;
          subscription_status?: 'free' | 'pro' | 'cancelled' | 'payment_failed';
          test_count?: number;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          email?: string;
          name?: string;
          subscription_status?: 'free' | 'pro' | 'cancelled' | 'payment_failed';
          test_count?: number;
          updated_at?: string;
        };
      };
      saju_tests: {
        Row: {
          id: string;
          user_id: string;
          name: string;
          birth_date: string;
          birth_time: string | null;
          gender: 'male' | 'female';
          result: string;
          model_used: 'flash' | 'pro';
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          name: string;
          birth_date: string;
          birth_time?: string | null;
          gender: 'male' | 'female';
          result: string;
          model_used: 'flash' | 'pro';
          created_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          name?: string;
          birth_date?: string;
          birth_time?: string | null;
          gender?: 'male' | 'female';
          result?: string;
          model_used?: 'flash' | 'pro';
          created_at?: string;
        };
      };
      subscriptions: {
        Row: {
          id: string;
          user_id: string;
          status: 'active' | 'cancelled' | 'payment_failed';
          next_billing_date: string | null;
          card_number: string | null;
          card_company: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          status?: 'active' | 'cancelled' | 'payment_failed';
          next_billing_date?: string | null;
          card_number?: string | null;
          card_company?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          status?: 'active' | 'cancelled' | 'payment_failed';
          next_billing_date?: string | null;
          card_number?: string | null;
          card_company?: string | null;
          updated_at?: string;
        };
      };
      payments: {
        Row: {
          id: string;
          user_id: string;
          subscription_id: string | null;
          amount: number;
          currency: string;
          status: 'pending' | 'completed' | 'failed' | 'cancelled';
          payment_key: string | null;
          order_id: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          subscription_id?: string | null;
          amount: number;
          currency?: string;
          status: 'pending' | 'completed' | 'failed' | 'cancelled';
          payment_key?: string | null;
          order_id?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          subscription_id?: string | null;
          amount?: number;
          currency?: string;
          status?: 'pending' | 'completed' | 'failed' | 'cancelled';
          payment_key?: string | null;
          order_id?: string | null;
          updated_at?: string;
        };
      };
    };
  };
};

export type SajuTest = Database['public']['Tables']['saju_tests']['Row'];
export type User = Database['public']['Tables']['users']['Row'];
export type Subscription = Database['public']['Tables']['subscriptions']['Row'];
export type Payment = Database['public']['Tables']['payments']['Row'];
</file>

<file path="package.json">
{
  "name": "template",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test:unit": "jest --config jest.config.js",
    "test:e2e": "playwright test",
    "test": "npm run test:unit && npm run test:e2e"
  },
  "dependencies": {
    "@clerk/nextjs": "^6.34.0",
    "@hookform/resolvers": "^4",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.6",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.58.0",
    "@tanstack/react-query": "^5",
    "@tosspayments/tosspayments-sdk": "^2.4.0",
    "axios": "^1.7.9",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4",
    "es-toolkit": "^1",
    "framer-motion": "^11",
    "hono": "^4.9.9",
    "lucide-react": "^0.469.0",
    "next": "15.1.0",
    "next-themes": "^0.4.3",
    "react": "^19.0.0",
    "react-day-picker": "^9.11.1",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7",
    "react-markdown": "^10.1.0",
    "react-use": "^17",
    "server-only": "0.0.1",
    "svix": "^1.80.0",
    "ts-pattern": "^5",
    "uuid": "^13.0.0",
    "zod": "^3",
    "zustand": "^4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@playwright/test": "^1.48.0",
    "@tailwindcss/postcss": "^4.1.13",
    "@tailwindcss/typography": "^0.5.10",
    "@types/jest": "^29.5.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/uuid": "^10.0.0",
    "dotenv": "^16.4.5",
    "eslint": "^9",
    "eslint-config-next": "15.1.0",
    "jest": "^29.7.0",
    "postcss": "^8",
    "tailwind-merge": "^2.5.2",
    "tailwindcss": "^4.1.13",
    "tailwindcss-animate": "^1.0.7",
    "ts-jest": "^29.1.1",
    "typescript": "^5"
  }
}
</file>

<file path="src/features/saju/actions/create-saju-test.ts">
'use server';

import { redirect } from 'next/navigation';
import { createClient } from '@/lib/supabase/server-client';
import { createAdminClient } from '@/lib/supabase/admin-client';
import { auth, currentUser } from '@clerk/nextjs/server';
import { geminiClient } from '@/lib/gemini/client';
import { generateSajuPrompt, generateProSajuPrompt } from '@/lib/gemini/prompts';
import { sajuInputSchema, type SajuInput } from '@/features/saju/types/input';

export type CreateSajuTestResult =
  | { success: true; testId: string }
  | { success: false; error: string };

export async function createSajuTest(
  input: SajuInput
): Promise<CreateSajuTestResult> {
  try {
    // 1. 입력 검증
    let validatedInput: SajuInput;
    try {
      validatedInput = sajuInputSchema.parse(input);
    } catch (error) {
      if (error instanceof Error && 'issues' in error) {
        const zodError = error as any;
        const firstIssue = zodError.issues[0];
        if (firstIssue?.path[0] === 'birthDate') {
          return { success: false, error: '생년월일을 YYYY-MM-DD 형식(예: 2000-01-01)으로 입력해주세요' };
        }
      }
      return { success: false, error: '입력 정보를 확인해주세요' };
    }

    // 2. 사용자 인증 확인
    const { userId } = await auth();
    
    if (!userId) {
      return { success: false, error: '로그인이 필요합니다' };
    }

    // 3. 사용자 정보 생성 또는 확인 (구독 상태 포함)
    const adminSupabase = createAdminClient();
    const { data: existingUser } = await (adminSupabase as any)
      .from('users')
      .select('id, subscription_status, test_count')
      .eq('id', userId)
      .single();

    let userInfo: { id: string; subscription_status: string; test_count: number } | null = existingUser;

    if (!existingUser) {
      // 사용자 정보 가져오기
      const user = await currentUser();
      if (!user) {
        return { success: false, error: '사용자 정보를 가져올 수 없습니다' };
      }

      const email = user.emailAddresses[0]?.emailAddress || '';
      const name = [user.lastName, user.firstName].filter(Boolean).join('') ||
                  email.split('@')[0] || 'Unknown';

      // 사용자 생성 (초기 구독 상태: free, 검사 횟수: 3)
      const { data: newUser, error: userError } = await (adminSupabase as any)
        .from('users')
        .insert({
          id: userId,
          email,
          name,
          subscription_status: 'free',
          test_count: 3,
        })
        .select('id, subscription_status, test_count')
        .single();

      if (userError || !newUser) {
        console.error('사용자 생성 실패:', userError);
        return { success: false, error: '사용자 정보 생성에 실패했습니다' };
      }

      userInfo = newUser;
    }

    // 4. 잔여 횟수 확인
    if (!userInfo || userInfo.test_count <= 0) {
      return {
        success: false,
        error: '검사 횟수가 부족합니다. 구독 페이지로 이동하시겠습니까?',
      };
    }

    // 5. 구독 상태에 따른 모델 선택
    const isPro = userInfo.subscription_status === 'pro' || userInfo.subscription_status === 'cancelled';
    const prompt = isPro
      ? generateProSajuPrompt(validatedInput)
      : generateSajuPrompt(validatedInput);

    // 6. Gemini API 호출
    const { text: result } = await geminiClient.generateContent(prompt);

    // 7. 데이터베이스 저장 (사용 모델 정보 포함)
    const { data: sajuTest, error: dbError } = await (adminSupabase as any)
      .from('saju_tests')
      .insert({
        user_id: userId,
        name: validatedInput.name,
        birth_date: validatedInput.birthDate,
        birth_time: validatedInput.birthTime || null,
        gender: validatedInput.gender,
        result,
        model_used: isPro ? 'pro' : 'flash',
      })
      .select()
      .single();

    if (dbError || !sajuTest) {
      console.error('데이터베이스 저장 실패:', dbError);
      return { success: false, error: '분석 결과 저장에 실패했습니다' };
    }

    // 8. 횟수 차감
    await (adminSupabase as any)
      .from('users')
      .update({ test_count: userInfo.test_count - 1 })
      .eq('id', userId);

    // 9. 상세 페이지로 리다이렉트 (redirect는 정상적인 동작이므로 catch하지 않음)
    redirect(`/dashboard/results/${(sajuTest as any).id}`);
  } catch (error) {
    // redirect()는 NEXT_REDIRECT를 던지므로 정상적인 동작
    if (error && typeof error === 'object' && 'digest' in error && 
        typeof error.digest === 'string' && error.digest.startsWith('NEXT_REDIRECT')) {
      throw error; // redirect를 다시 던져서 정상 처리
    }

    console.error('사주분석 생성 실패:', error);

    if (error instanceof Error) {
      return { success: false, error: error.message };
    }

    return { success: false, error: '분석 중 오류가 발생했습니다' };
  }
}
</file>

</files>
